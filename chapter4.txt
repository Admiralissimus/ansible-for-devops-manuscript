# Chapter 4 - Ansible Playbooks

## Power plays

Like many other configuration management solutions, Ansible uses a metaphor to describe it's configuration files. They are called 'playbooks', and they list a set of tasks ('plays' in Ansible parlance) that will be run against a particular server or set of servers.

Playbooks are written in [YAML](http://docs.ansible.com/YAMLSyntax.html), a human-readable data format that is very popular for defining configuration in a simple text format. They can be included within other playbooks, and certain metadata and options can cause different plays or playbooks to be run in different scenarios on different servers. Think of a football (American, not the game played with your feet) playbook; there are many different plays that can be run, and the coaches will pick the plays appropriate for a given situation. You will write many different plays, and you can use some on all servers, some on a few types of servers, and some on just one or two servers---as the current situation requires.

Ad-hoc commands alone can make Ansible a powerful tool; playbooks turn Ansible into a top-notch server provisioning and configuration management tool.

What attracts most DevOps personnel to Ansible is the fact that it is easy to convert shell scripts (or one-off shell commands) directly into Ansible plays. Consider the following script, which simply installs Apache on a CentOS/Fedora server:

**Shell Script**

{lang="bash"}
    # Install Apache.
    yum install --quiet -y httpd httpd-devel
    # Copy configuration files.
    cp /path/to/config/httpd.conf /etc/httpd/conf/httpd.conf
    cp /path/to/config/httpd-vhosts.conf /etc/httpd/conf/httpd-vhosts.conf
    # Start Apache and configure it to run at boot.
    service httpd start
    chkconfig httpd on

**Ansible Playbook**

{lang="yaml"}
    ---
    - hosts: all
      tasks:
      - name: Install Apache.
        command: yum install --quiet -y httpd httpd-devel
      - name: Copy configuration files.
        command: cp /path/to/config/httpd.conf /etc/httpd/conf/httpd.conf
      - command: cp /path/to/config/httpd-vhosts.conf /etc/httpd/conf/httpd-vhosts.conf
      - name: Start Apache and configure it to run at boot.
        command: service httpd start
      - command: chkconfig httpd on

Ansible is powerful in that you can quickly transition to using playbooks if you know how to write standard shell commands---the same commands you've been using for years---and then rebuild your configuration to be more robust and take advantage of Ansible's features as you get time.

In the above playbook, we are simply using the `command` module to run standard shell commands. We're also giving each play a 'name', so when we run the playbook, the play has human-readable output on the screen or in the logs. The command module has some other tricks up its sleeve (which we'll see later), but for now, you can be assured that shell scripts can be translated directly into Ansible playbooks without much hassle.

The above playbook will perform *exactly* like the shell script, but we can improve things greatly by using some of Ansible's built-in modules to handle the heavy lifting:

**Revised Ansible Playbook - Now with 100% more idempotence!**

{lang="yaml"}
    ---
    - hosts: all
      tasks:
      - name: Install Apache.
        yum: pkg={{ item }} state=present
        with_items:
        - httpd
        - httpd-devel
      - name: Copy configuration files.
        copy: src={{ item.src }} dest={{ item.dest }} owner=root group=root mode=0644
        with_items:
        - {src: "/path/to/config/httpd.conf", dest: "/etc/httpd/conf/httpd.conf"}
        - {src: "/path/to/config/httpd-vhosts.conf", dest: "/etc/httpd/conf/httpd-vhosts.conf"}
      - name: Make sure Apache is started and configure it to run at boot.
        service: name=httpd state=started enabled=yes

Now we're getting somewhere. Let me walk you through this simple playbook:

  1. The first line, `---`, is how we mark this document as using YAML syntax (like using `<html>` at the top of an HTML document, or `<?php` at the top of a block of PHP code).
  2. The second line, `tasks:`, tells Ansible that what follows is a list of tasks to run as part of this playbook.
  3. The first task begins with `name: Install Apache.`. `name` is not a module that does something to your server; rather, it's a way of giving a human-readable description to the play that follows. Seeing "Install Apache" is more relevant than seeing "yum pkg=httpd state=installed"... but if you drop the name line completely, that won't cause any problem.

     - We use the `yum` module to install Apache. Instead of the command `yum -y install httpd httpd-devel`, we can describe to Ansible exactly what we want. Ansible will take the `items` array we pass in (`{{ variable }}` references a variable in Ansible's playbooks). We tell yum to make sure the packages we define are installed with `state=present`, but we could also use `state=latest` to ensure the latest version is installed, or `state=absent` if we want to make sure the package is *not* installed.
     - Ansible allows simple lists to be passed into plays using `with_items`: Simply define a list of items below, and each line will be passed into the play, one by one. In this case, each of the items will be substituted for the `{{ item }}` variable.

  4. The second task again starts with a human-readable name (which could be left out if you'd like).

     - We use the `copy` module to copy files from a source (on our local workstation) to a destination (the server being managed). We can also pass in more variables, like file metadata including ownership and permissions (`owner`, `group`, and `mode`).
     - In this case, we are using an array with multiple elements for variable substitution; you use the syntax `{var1: value, var2: value}` to define each element (it can have as many variables as you want within, or even nested levels of variables!). When you reference the variables in the play, you simply use a dot to access the variable within the item, so `{{ item.var1 }}` would access the first variable. In our example, `item.src` access the `src` in each item.

  5. The third task also uses a name to describe it in a human-readable format.

     - We use the `service` module to describe the desired state of a particular service, in this case `httpd`, Apache's http daemon. We want it to be running, so we set `state=started`, and we want it to run at system startup, so we say `enabled=yes` (the equivalent of running `chkconfig httpd on`).

The great thing about the way we've reformatted this list of commands is that now, Ansible can keep track of the state of everything on all our servers. If you run the playbook the first time, it will provision the server by ensuring Apache is installed and running, and your custom configuration is in place.

What's even more powerful is that the *second* time you run it, it won't actually do anything---besides telling you nothing has changed---as long as the server is in the correct state. So, with this one short playbook, we're able to provision and ensure the proper configuration for an Apache web server.

If you ever want to update your configuration, or install another httpd package, you can simply update the file locally, or add the package to the `with_items` list, and run the playbook again. Whether you have one or a thousand servers, all of their configurations will be updated to match your playbook---and Ansible will tell you if anything ever changes (you're not making ad-hoc changes on individual production servers, *are you*?).

## Real-world playbook: CentOS Node.js app server

The above example, while being helpful for someone who might want to post a simple static web page to a clunky old Apache server, is not a good representation of a real-world scenario. I'm going to run through some more complex playbooks that do many different things, most of which are actually being used to manage production infrastructure today.

![Node.js app on CentOS.](images/4-playbook-nodejs.png)

### Add extra repositories

Adding extra package repositories (yum or apt) is one thing many admins will do before any other work on a server to ensure that certain packages are available, or are at a later version than the ones in the base installation.

In the shell script below, we want to add both the EPEL and Remi repositories, so we can get some packages like Node.js or later versions of software like MySQL or PHP (these examples presume you're running RHEL/CentOS 6.x):

{lang="bash"}
    # Import EPEL GPG Key - see: https://fedoraproject.org/keys
    wget https://fedoraproject.org/static/0608B895.txt -O /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
    rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
    
    # Import Remi GPG key - see: http://rpms.famillecollet.com/RPM-GPG-KEY-remi
    wget http://rpms.famillecollet.com/RPM-GPG-KEY-remi -O /etc/pki/rpm-gpg/RPM-GPG-KEY-remi
    rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-remi
    
    # Install EPEL and Remi repos.
    rpm -Uvh --quiet http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
    rpm -Uvh --quiet http://rpms.famillecollet.com/enterprise/remi-release-6.rpm
    
    # Install Node.js (npm plus all its dependencies).
    yum --enablerepo=epel install node

This shell script uses the rpm command to import the EPEL and Remi repository GPG keys, then adds the repositories, and finally installs Node.js. It works okay for a simple deployment (or by hand), but it's silly to run all these commands (some of which could take time or stop your script entirely if your connection is flaky or bad) if the result has already been achieved (namely, two repositories and their GPG keys have been added).

I> If you wanted to skip a couple steps, you could skip adding the GPG keys, and just run your commands with `--nogpgcheck` (or, in Ansible, set the `disable_gpg_check` parameter of the yum module to `yes`), but it's a good idea to leave this enabled. GPG stands for *GNU Privacy Guard*, and it's a way that developers and package distributors can sign their packages (so you know it's from the original author, and hasn't been modified or corrupted). Unless you *really* know what you're doing, don't disable security settings like GPG key checks.

Ansible can make things a little more robust. Even though the following is slightly more verbose, it performs the same actions in a more structured way, which is simpler to understand, and can work with variables other nifty Ansible features we'll discuss later:

{lang="yaml"}
    - name: Import EPEL and Remi GPG keys.
      rpm_key: key={{ item }} state=present
      with_items:
      - "https://fedoraproject.org/static/0608B895.txt"
      - "http://rpms.famillecollet.com/RPM-GPG-KEY-remi"
    
    - name: Install EPEL and Remi repos.
      command: rpm -Uvh --force {{ item.href }} creates={{ item.creates }}
      with_items:
      - {
        href: "http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm",
        creates: "/etc/yum.repos.d/epel.repo"
      }
      - {
        href: "http://rpms.famillecollet.com/enterprise/remi-release-6.rpm",
        creates: "/etc/yum.repos.d/remi.repo"
      }
    
    - name: "Common: Disable firewall (since this is a dev environment)."
      service: name=iptables state=stopped enabled=no
    
    - name: Install Node.js (npm plus all it's dependencies).
      yum: pkg=npm state=present enablerepo=epel
    
    - name: "Node: Install forever module (to run our Node.js app)."
      npm: name=forever global=yes state=latest

Let's walk through this playbook step-by-step:

  1. `rpm_key` is a very simple Ansible module that takes and imports an RPM key from a URL or file, or the keyid of an key that is already present, and can ensure the key is either present or absent (the `state` parameter). We want to import two keys---one for EPEL from the Fedora project, and one for the Remi Repository.
  2. Since Ansible doesn't have a built-in rpm module, we simply use the rpm command, but we use Ansible's `command` module, which allows us to do two things:

     1. Use the `creates` parameter to tell Ansible when to *not* run the command (in this case, we tell Ansible what file is present after the `rpm` command successfully completes).
     2. Use an multidimensional array of items (`with_items`) so we can define URLs and the resulting file that can be checked with `creates`.

  3. `yum` installs Node.js (along with all the required packages for `npm`, Node's package manager) if it's not present, and allows the EPEL repo to be searched via the `enablerepo` parameter (you could also explicitly *disable* a repository using `disablerepo`).
  4. Since NPM is now installed, we can use Ansible's `npm` module to install a Node.js utility, `forever`, so we can easily launch our app and keep it running. Setting `global` to `yes` tells NPM to install the `forever` node module in `/usr/lib/node_modules/` so it will be available to all users and Node.js apps on the system.

We're beginning to have a nice little Node.js app server set up. Let's set up a little Node.js app that responds to HTTP requests on port 80.

### Deploy a Node.js app

The next step is to install a simple Node.js app on our server. First, we'll create a really simple Node.js app by creating a new folder, `app`, in the same folder as your playbook.yml. Create a new file, `app.js`, in this folder, with the following contents:

{lang="js"}
    // Load the express module.
    var express = require('express'),
    app = express.createServer();
    
    // Respond to requests for / with 'Hello World'.
    app.get('/', function(req, res){
        res.send('Hello World!');
    });
    
    // Listen on port 80 (like a true web server).
    app.listen(80);
    console.log('Express server started successfully.');

Don't worry about the syntax or the fact that this is Node.js. We just need a quick example to deploy. This example could've been written in Python, Perl, Java, PHP, or another language, but since Node is a very simple language (JavaScript) that runs in a very simple and lightweight environment, it's a nice (and easy) language to use when testing things or prodding your server.

Since this little app is dependent on Express (a simple http framework for Node), we also need to tell NPM about this dependency via a `package.json` file in the same folder as `app.js`:

{lang="js"}
    {
      "name": "examplenodeapp",
      "description": "Example Express Node.js app.",
      "author": "Jeff Geerling <geerlingguy@mac.com>",
      "dependencies": {
        "express": "3.x.x"
      },
      "engine": "node >= 0.10.6"
    }

Now, add the following to your playbook, to copy the entire app to the server, and then have NPM download the required dependencies (in this case, `express`):

{lang="yaml",starting-line-number=28}
    - name: "Node: Ensure Node.js app folder exists."
      file: path={{ node_apps_location }} state=directory
    
    - name: "Node: Copy example Node.js app to server."
      copy: src=app dest={{ node_apps_location }}
    
    - name: "Node: Install app dependencies defined in package.json via npm."
      npm: path={{ node_apps_location }}/app

First, we ensure the directory where our app will be installed exists, using the `file` module. The `{{ node_apps_location }}` variable used in each command can be defined under a `vars` section at the top of our playbook, in your inventory, or on the command line when calling `ansible-playbook`.

Second, we copy the entire app folder up to the server, using Ansible's `copy` command, which intelligently distinguishes between a single file or a directory of files, and recurses through the directory, similar to recursive scp or rsync.

T> Ansible's `copy` module works very well for single or small groups of files, and recurses through directories automatically. If you are copying hundreds of files, or deeply-nested directory structures, `copy` will get bogged down. In these situations, consider using the `synchronize` module if you need to copy a full directory, or `unarchive` if you want to copy up an archive and have it expanded in place on the server.

Third, we use `npm` again, this time, with no extra arguments besides the path to the app. This tells NPM to parse the package.json file and ensure all the dependencies are present.

We're *almost* finished! The last step is to start the app.

### Launch a Node.js app

We'll now use `forever` (which we installed earlier) to start the app.

{lang="yaml",starting-line-number=36}
    - name: "Node: Check list of Node.js apps running."
      command: forever list
      register: forever_list
      changed_when: false
    
    - name: "Node: Start example Node.js app."
      command: forever start {{ node_apps_location }}/app/app.js
      when: "forever_list.stdout.find('{{ node_apps_location}}/app/app.js') == -1"

In the first play, we're doing two new things:

  1. `register` creates a new variable, `forever_list`, to be used in the next play to determine when to run the play. `register` stashes the output (stdout, stderr) of the defined command in the variable name passed to it.
  2. `changed_when` tells Ansible explicitly when this play results in a change to the server. In this case, we know the `forever list` command will never change the server, so we just say `false`---the server will never be changed when the command is run.

The second play actually starts the app, using forever. We could also start the app by calling `node {{ node_apps_location }}/app/app.js`, but we would not be able to control the process easily, and we would also need to use `nohup` and `&` to avoid Ansible hanging on this play.

Forever tracks the Node apps it manages, and we use Forever's `list` option to print a list of running apps. The first time we run this playbook, the list will obviously be empty---but on future runs, if the app is running, we don't want to start another instance of it. To avoid that situation, we tell ansible when we want to start the app with `when`. Specifically, we tell Ansible to start the app only when the app's path in *not* in the `forever list` output.

### Node.js app server summary

At this point, you have a complete playbook that will install a simple Node.js app which responds to HTTP requests on port 80 with "Hello World!".

To run the playbook on a server (in our case, we could just set up a new VirtualBox VM for testing, either via Vagrant or manually), use the following command (if you want to pass the `node_apps_location` variable via the command):

{lang="text",linenos=off}
    $ ansible-playbook provisioning/playbook.yml -i /path/to/custom/inventory-file --extra-vars="node_apps_location=/usr/local/opt/node"

Simple, but very powerful. We've configured an entire Node.js application server In fewer than seventy lines of YAML!

## Real-world playbook: Ubuntu LAMP server with Drupal

At this point, you should be getting comfortable with Ansible playbooks and the YAML syntax used to define them. Up to this point, most examples have assumed you're working with a CentOS, RHEL, or Fedora server. Ansible plays nicely with other flavors of Linux and BSD-like systems as well. In the following example, we're going to set up a traditional LAMP (Linux, Apache, MySQL, and PHP) server using Ubuntu 12.04 to run a Drupal website.

![Drupal LAMP server.](images/4-playbook-drupal.png)

### Include a variables file, and discover `pre_tasks` and `handlers`

For this playbook, we're going to start organizing our playbook a little more efficiently. Instead of defining any inline variables, let's begin the playbook by telling Ansible our variables will be in a separate `vars.yml` file:

{lang="text"}
    - hosts: all
    
      vars_files:
      - vars.yml

Using one or more variable files, rather than defining everything inline, cleans up your main playbook file, and lets you organize all your configurable variables in one place. For now, we don't have any variables to add; we'll define the contents of `vars.yml`  later. For now, create the empty file, and continue on to the next section of the playbook, `pre_tasks`:

{lang="text",starting-line-number=5}
      pre_tasks:
      - name: Update apt cache if needed.
        apt: update_cache=yes cache_valid_time=3600

Ansible lets you run plays before or after the main set of plays using `pre_tasks` and `post_tasks`. In this case, we need to ensure that our apt cache is updated before we run the rest of the playbook, so we have the latest package versions on our server. We use Ansible's `apt` module and simply tell it to update the cache if it's been more than 3600 seconds (1 hour) since the last update.

With that out of the way, we'll add another new section to our playbook, `handlers`:

{lang="text",starting-line-number=8}
      handlers:
      - name: restart apache
        command: service apache2 restart

`handlers` are special kinds of plays that you can run at the end of a group of plays by adding the `notify` option to any of the plays in that group. The handler will only be called if one of the plays notifying the handler makes a change to the server (and doesn't fail), and it will only be notified at the *end* of the group of plays.

To call this handler, you simply add the option `notify: restart apache` after defining the rest of a play. We've defined this handler so we can restart the `apache2` service after a configuration change, which will be explained below.

I> Just like variables, handlers and plays may be placed in separate files and included in your playbook to keep things tidy. For simplicity's sake, though, the examples in this chapter are shown as in a single playbook file. We'll discuss different playbook organization methods later.

### Basic LAMP server setup

The first step towards building an application server that depends on the LAMP stack is to build the actual LAMP part of it. This is the simplest process, but still requires a little extra work for our particular server. We want to install Apache, MySQL and PHP, but we'll also need a couple other dependencies, and we want a particular version of PHP (5.5), which is only available in an extra apt repository.

{lang="text",starting-line-number=11}
      tasks:
      - name: "Common: Get software for apt repository management."
        apt: pkg={{ item }} state=installed
        with_items:
        - python-apt
        - python-pycurl
      
      - name: "Common: Add ondrej repository for later versions of PHP."
        # Note: You can remove '-oldstable' for PHP 5.5.x.
        apt_repository: repo='ppa:ondrej/php5-oldstable'
      
      - name: "Common: Install Apache, MySQL, PHP, and other dependencies."
        apt: pkg={{ item }} state=installed
        with_items:
        - git
        - curl
        - sendmail
        - apache2
        - php5
        - php5-common
        - php5-mysql
        - php5-cli
        - php5-curl
        - php5-gd
        - php5-dev
        - php5-mcrypt
        - php-apc
        - php-pear
        - python-mysqldb
        - mysql-server
      
      - name: "Common: Disable the firewall (since this is for local dev only)."
        service: name=ufw state=stopped
      
      - name: "Common: Start Apache, MySQL, and PHP."
        service: name={{ item }} state=started enabled=yes
        with_items:
        - apache2
        - mysql

In this playbook, I've decided to add a simple prefix to each named play, so I can more easily follow the playbook's progress when it's running. I've begun with the common LAMP setup:

  1. Install a couple helper libraries which allow Python to manage apt more precisely (`python-apt` and `python-pycurl` are required for the `apt_repository` module to do its work).
  2. Since the default apt repositories for Ubuntu 12.04 don't include PHP 5.4.x (or any later versions), install ondrej's `PHP5-oldstable` repository, containing PHP 5.4.25 (at the time of this writing) and other associated PHP packages.
  3. Install all the required packages for our LAMP server (including all the php5 extensions we need to run Drupal).
  4. Disable the firewall entirely, for testing purposes. If on a production server or any server exposed to the Internet, you should instead have a restrictive firewall only allowing access on ports 22, 80, 443, and other necessary ports.
  5. Start up all the required services, and make sure they're enabled to start on system boot.

### Configure Apache

The next step is configuring Apache so it will work correctly with Drupal. Out of the box, Apache doesn't have mod_rewrite enabled on Ubuntu 12.04. To remedy that situation, you can use the command `a2enable`, or simply copy `rewrite.load` from mods-available to mods-enabled (we'll do the latter).

Additionally, we need to add a VirtualHost entry to tell Apache where the site's document root is, and any other options for the site.

{lang="text",starting-line-number=50}
      - name: "Apache: Enable mods required for Drupal."
        file: src=/etc/apache2/mods-available/{{ item }} dest=/etc/apache2/mods-enabled/{{ item }} state=link
        with_items:
        - rewrite.load
        notify: restart apache
      
      - name: "Apache: Add Apache virtualhost for Drupal 8 development."
        template: src=templates/drupal.dev.conf.j2 dest=/etc/apache2/sites-available/{{ domain }}.dev.conf owner=root group=root mode=0644
        notify: restart apache
      
      - name: "Apache: Symlink Drupal virtualhost to sites-enabled."
        file: src=/etc/apache2/sites-available/{{ domain }}.dev.conf dest=/etc/apache2/sites-enabled/{{ domain }}.dev.conf state=link
        notify: restart apache
      
      - name: "Apache: Remove default virtualhost file."
        file: path=/etc/apache2/sites-enabled/000-default state=absent
        notify: restart apache

The first command enables all the required Apache modules by symlinking them from `/etc/apache2/mods-available` to `/etc/apache2/mods-enabled`.

The second command copies a Jinja2 template we define inside the templates folder to Apache's `sites-available` folder, with the correct owner and permissions. Additionally, we `notify` the `restart apache` handler, because copying in a new VirtualHost means Apache needs to be restarted to pick up the change.

Let's look at our Jinja2 template (denoted by the extra `.j2` on the end of the filename), `drupal.dev.conf.j2`:

{lang="jinja"}
    <VirtualHost *:80>
        ServerAdmin webmaster@localhost
        ServerName {{ domain }}.dev
        ServerAlias www.{{ domain }}.dev
        DocumentRoot /var/www/drupal-{{ drupal_core_version }}-dev
        <Directory "/var/www/drupal-{{ drupal_core_version }}-dev">
            Options FollowSymLinks Indexes
            AllowOverride All
        </Directory>
    </VirtualHost>

This is a fairly standard Apache VirtualHost definition, but we have a few Jinja2 template variables mixed in. The syntax for printing a variable in a Jinja2 template is the same syntax we use in our Ansible playbooks---two brackets around the variable's name (like so: `{{ variable }}`).

There are two variables we will need (`domain` and `drupal_core_version`), so we can add them to the empty `vars.yml` file we created earlier:

{lang="yaml"}
    ---
    # The core version you want to use (e.g. 6.x, 7.x, 8.x).
    drupal_core_version: "8.x"

    # The resulting domain will be [domain].dev (with .dev appended).
    domain: "drupaltest"

Now, when Ansible reaches the play that copies this template into place, the Jinja2 template will have the variable names replaced with the values `8.x` and `drupaltest` (or whatever values you'd like!).

The last two plays (lines 12-19) enable the VirtualHost we just added, and remove the default VirtualHost definition, which we no longer need.

At this point, you could start the server, but Apache will likely throw an error since the VirtualHost you've defined doesn't yet exist (there's no directory at `/var/www/drupal-{{ drupal_core_version }}-dev` yet!). This is why using `notify` is important---instead of adding a play after these three steps to restart Apache, which will fail the first time you run the playbook, notify will wait until after we've finished all the other steps in our main group of plays (giving us time to finish setting up the server), *then* restart Apache.

### Configure PHP with `lineinfile`

We briefly mentioned `lineinfile` earlier in the book, when discussing file management and ad-hoc task execution. Modifying PHP's configuration is a perfect way to demonstrate `lineinfile`'s simplicity and usefulness:

{lang="text",starting-line-number=70}
      - name: "PHP: Enable upload progress via APC."
        lineinfile: >
          dest=/etc/php5/conf.d/20-apc.ini
          regexp="^apc\.rfc1867"
          line="apc.rfc1867 = 1"
        notify: restart apache

Ansible's `lineinfile` module does a simple task: ensures that a particular line of text exists (or doesn't exist) in a file.

In this example, we need to enable APC's `rfc1867` option so Drupal can use APC's file upload progress tracking (there are better ways of doing this, but for our simple server, this will suffice).

First, we tell `lineinfile` the location of the file, in the `dest` parameter. Then, we give a regular expression (Python-style) to define what the line looks like (in this case, the line starts with the exact phrase "apc.rfc1867"---we had to escape the period since it is a special character in regular expressions). Finally, we tell `lineinfile` exactly how the line should look.

Ansible will take the regular expression, and see if there's a matching line. If there is, Ansible will make sure the line matches the `line` parameter. If not, Ansible will add the line as defined in the `line` parameter. Ansible will only report a change if it had to add or change the line to match `line`.

T> You may have noticed the greater-than sign (`>`) immediately following the `lineinfile:` module directive; this is a way of saying "automatically quote the next set of indented lines as if they were in one big concatenated list". It helps when you have more complex modules like `lineinfile` to format the parameters one-per-line (instead of in order on one line like `dest=/path/to/file regexp="expression" line="new line"`, for two reasons: it's easier to see what each option is doing, and your source control software is better able to identify specific changes on a line-by-line basis.

### Configure MySQL

The next step is to remove MySQL's default test database, and create a database (named for the domain we specified earlier) for our Drupal installation to use.

{lang="text",starting-line-number=76}
      - name: "MySQL: Remove the MySQL test database."
        mysql_db: db=test state=absent
      
      - name: "MySQL: Create a database for Drupal."
        mysql_db: db={{ domain }} state=present

MySQL installs a database named `test` by default, and it is recommended that you remove the database as part of MySQL's included `mysql_secure_installation` tool. The first step in configuring MySQL is removing this database. Next, we create a database named `{{ domain }}`---the database is named the same as the domain we're using for the Drupal site.

I> Ansible works with many databases out of the box (MongoDB, MySQL, PostgreSQL, Redis and Riak as of this writing). In MySQL's case, Ansible uses the MySQLdb Python package (`python-mysqldb`) to manage a connection to the database server, and assumes the default root account credentials ('root' as the username with no password). Obviously, leaving this default would be a bad idea! On a production server, one of the first steps should be to change the root account password, limit the root account to localhost, and delete any nonessential database users.
I> 
I> If you use different credentials, you can add a .my.cnf file to your remote user's home directory containing the database credentials so Ansible can connect to the MySQL database without leaving passwords in your Ansible playbooks or variable files. Otherwise, you can prompt the user running the Ansible playbook for a MySQL username and password. This option, using prompts, will be discussed later in the book.

### Install Composer and Drush

Drupal has a command-line companion in the form of Drush. Drush is developed independently of Drupal, and provides a full suite of CLI commands to manage Drupal. Drush, like most modern PHP tools, integrates with external dependencies defined in a `composer.json` file which describes the dependencies to Composer.

We could just download Drupal and perform some setup in the browser by hand at this point, but the goal of this playbook is to have a fully-automated and idempotent Drupal installation. So, we need to install Composer, then Drush:

{lang="text",starting-line-number=81}
      - name: "Composer: Install Composer into the current directory."
        shell: curl -sS https://getcomposer.org/installer | php creates=/usr/local/bin/composer
      
      - name: "Composer: Move Composer into globally-accessible location."
        shell: mv composer.phar /usr/local/bin/composer creates=/usr/local/bin/composer

The first command runs Composer's php-based installer, which generates a 'composer.phar' PHP application archive. This archive is then copied (using the `mv` shell command) to the location `/usr/local/bin/composer` so we can use the simple `composer` command to install all of Drush's dependencies. Both commands are set to only run if the `/usr/local/bin/composer` file doesn't already exist (using the `creates` parameter).

Now, we'll install Drush using the latest version from GitHub:

{lang="text",starting-line-number=87}
      - name: "Drush: Check out drush master branch so it works with all Drupal versions."
        git: repo=https://github.com/drush-ops/drush.git dest=/opt/drush
      
      - name: "Install Drush dependencies with Composer."
        shell: >
          /usr/local/bin/composer install
          chdir=/opt/drush
          creates=/opt/drush/vendor/autoload.php
      
      - name: "Drush: Create drush bin symlink."
        file: src=/opt/drush/drush dest=/usr/local/bin/drush state=link

Earlier in the book, we cloned a git repository using an ad-hoc command. In this case, we're defining a play that uses the `git` module to clone Drush from it's repository URL on GitHub. Since we want the master branch, we simply pass in the `repo` (repository URL) and `dest` (destination path) parameters.

After drush is downloaded to `/opt/drush`, we use Composer to install all the required dependencies. In this case, we want Ansible to run `composer install` in the directory `/opt/drush` (this is so Composer can find drush's `composer.json` file automatically), so we pass along the parameter `chdir=/opt/drush`. Once Composer is finished, the file `/opt/drush/vendor/autoload.php` will be created, so we use the `creates` parameter to tell Ansible to skip this step if the file already exists (for idempotency).

Finally, we create a symlink from `/usr/local/bin/drush` to the executable at `/opt/drush/drush`, so we can call the `drush` command anywhere on the system.

### Install Drupal with Git and Drush

We'll use `git` again to clone Drupal to the apache document root we defined earlier in our virtual host configuration, then we'll run Drupal's installation via drush, and fix a couple other file permissions issues so Drupal loads correctly within our VM.

{lang="text",starting-line-number=98}
      - name: "Drupal: Check out Drupal Core to the Apache docroot."
        git:
          repo=http://git.drupal.org/project/drupal.git
          version={{ drupal_core_version }}
          dest=/var/www/drupal-{{ drupal_core_version }}-dev
      
      - name: "Drupal: Install Drupal."
        command:
          drush si -y --site-name="{{ drupal_site_name }}" --account-name=admin --account-pass=admin --db-url=mysql://root@localhost/{{ domain }}
          chdir=/var/www/drupal-{{ drupal_core_version }}-dev
          creates=/var/www/drupal-{{ drupal_core_version }}-dev/sites/default/settings.php
        notify: restart apache
      
      # SEE: https://drupal.org/node/2121849#comment-8413637
      - name: "Drupal: Set permissions properly on settings.php."
        file: path=/var/www/drupal-{{ drupal_core_version }}-dev/sites/default/settings.php mode=0744
      
      - name: "Drupal: Set permissions properly on files directory."
        file: path=/var/www/drupal-{{ drupal_core_version }}-dev/sites/default/files mode=0777 state=directory recurse=yes

First, we cloned Drupal's git repository, using the `version` defined in our `vars.yml` file as `drupal_core_version`. The `git` module's `version` parameter defines the branch (`master`, `8.x`, etc.), tag (`1.0.1`, `7.24`, etc.), or individual commit hash (`50a1877`, etc.) to clone.

Next, we used Drush's `si` command (short for `site-install`) to run Drupal's installation (which configures the database, runs some maintenance, and sets some default configuration settings for the site). We passed in a few variables, like the `drupal_core_version` and `domain`; we also added a `drupal_site_name`, so add that variable to your `vars.yml` file:

{lang="yaml",starting-line-number=7}
    # Your Drupal site name.
    drupal_site_name: "D8 Test"

Also, Drupal's installation process results in the creation of a 'settings.php' file, so we use the location of that file with the `creates` parameter to let Ansible know if the site's already installed (so we don't accidentally try installing it again!). Once the site is installed, we also restart Apache for good measure (using `notify` again, like we did when updating Apache's configuration).

The final two tasks set permissions on Drupal's settings.php and files folder to 744 and 777, respectively.

### Drupal LAMP server summary

At this point, if you access the server at http://drupaltest.dev/ (assuming you've pointed drupaltest.dev to your server or VM's IP address), you'll see Drupal's default home page, and you could login with 'admin'/'admin'. (Obviously, you'd set a secure password on a production server!).

A similar server configuration, running Apache, MySQL, and PHP, can be used to run many popular web frameworks and CMSes besides Drupal, including Symfony, Wordpress, Joomla, Laravel, etc.

## Real-world playbook: Ubuntu Apache Tomcat server with Solr

TODO.

## Summary

At this point, you should be getting comfortable with Ansible's *modus operandi*. Playbooks are the heart of Ansible's configuration management and provisioning functionality, and the same modules and similar syntax can be used with ad-hoc commands for deployments and general server management.

Now that you're familiar with playbooks, we'll explore more advanced concepts in building playbooks, like organization of plays, conditionals, variables, and more.

{lang="text",linenos=off}
     _________________________________________
    / If everything is under control, you are \
    \ going too slow. (Mario Andretti)        /
     -----------------------------------------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||
