# Chapter 6 - Playbook Organization - Roles and Includes

So far, we've used fairly straightforward examples in this book. Most examples are ad-hoc for a particular server, and listing all tasks in one long listing makes for a fairly long playbook.

Ansible is very flexible when it comes to organizing your plays in more efficient ways so you can make your playbooks more maintainable, reusable, and powerful. We'll look at two ways to split up plays more efficiently: using includes and roles. Finally, we'll explore Ansible Galaxy, a repository of some community-maintained roles that help configure common packages and applications.

## Includes

We've already seen one of the most basic ways of including other files in Chapter 4, when `vars_files` was used to place variables into a separate `vars.yml` file instead of inline with the playbook:

{lang="text",linenos=off}
    - hosts: all
    
      vars_files:
      - vars.yml

Tasks can easily be included in a similar way. In the `tasks:` section of your playbook, you can add `include` directives like so:

{lang="text",linenos=off}
    tasks:
      - include: included-playbook.yml

Just like with variable include files, tasks are formatted in a flat list in the included file. As an example, the `included-playbook.yml` could look like:

{lang="text",linenos=off}
    ---
    - name: Add profile info for user.
      copy:
        src: example_profile
        dest: "/home/{{ username }}/.profile"
        owner: "{{ username }}"
        group: "{{ username }}"
        mode: 0744
    
    - name: Add private keys for user.
      copy:
        src: "{{ item.src }}"
        dest: "/home/.ssh/{{ item.dest }}"
        owner: "{{ username }}"
        group: "{{ username }}"
        mode: 0600
      with_items: ssh_private_keys
    
    - name: Restart example service.
      service: name=example state=restarted

In this case, you'd probably want to name the file `user-config.yml`, since it's used to configure a user account and restart some service. Now, in this and any other playbook that provisions or configures a server, if you want to configure a particular user's account, add the following in your playbook's `tasks` section:

{lang="text",linenos=off}
    - include: example-app-config.yml

We used `{{ username }}` and `{{ ssh_private_keys }}` variables in this include file instead of hard-coded values so we could make this include file reusable. You could define the variables in your playbook's inline variables or an included variables file, but Ansible also lets you pass variables directly into includes using normal YAML syntax. For example:

{lang="text",linenos=off}
    - { include: user-config.yml, username: johndoe, ssh_private_keys: [] }
    - { include: user-config.yml, username: janedoe, ssh_private_keys: [] }

To make the syntax more readable, you can use structured variables, like so:

{lang="text",linenos=off}
    - include: user-config.yml
      vars:
        username: johndoe
        ssh_private_keys:
          - { src: /path/to/johndoe/key1, dest: id_rsa }
          - { src: /path/to/johndoe/key2, dest: id_rsa_2 }
    - include: user-config.yml
      vars:
        username: janedoe
        ssh_private_keys:
          - { src: /path/to/janedoe/key1, dest: id_rsa }
          - { src: /path/to/janedoe/key2, dest: id_rsa_2 }

Include files can even include other files, so you could have something like the following:

{lang="text",linenos=off}
    tasks:
      - include: user-config.yml

*inside `user-config.yml`*

{lang="text",linenos=off}
    - include: ssh-setup.yml

### Handler includes

Handlers can be included just like tasks, within a playbook's `handlers` section. For example:

{lang="text",linenos=off}
    handlers:
      - include: included-handlers.yml

This can be helpful in limiting the noise in your main playbook, since handlers are usually used for things like restarting services or loading a configuration, and can distract from the playbook's primary purpose.

### Playbook includes

Playbooks can even be included in other playbooks, by simply using the same `include` syntax in the top level of your playbook. For example, if you have two playbooks---one to set up your webservers (`web.yml`), and one to set up your database servers (`db.yml`), you could use the following playbook to run both at the same time:

{lang="text",linenos=off}
    - hosts: all
      remote_user: root
      
      tasks:
        ...
      
    - include: web.yml
    - include: db.yml

This way, you can create playbooks to configure all the servers in your entire infrastructure, then create a master playbook that includes each of the individual playbooks. When you want to initialize your entire infrastructure, make changes across your entire fleet of servers, or just check to make sure their configuration matches your playbook definitions, you can run one `ansible-playbook` command!

### Complete includes example

What if I told you we could remake the 137-line Drupal LAMP server playbook from Chapter 4 in just 21 lines? With includes, it's easy; just break out each of the sets of tasks into their own include files, and you'll end up with a main playbook like this:

{lang="text"}
    ---
    - hosts: all
    
      vars_files:
        - vars.yml
    
      pre_tasks:
        - name: Update apt cache if needed.
          apt: update_cache=yes cache_valid_time=3600
    
      handlers:
        - include: handlers/handlers.yml
    
      tasks:
        - include: tasks/common.yml
        - include: tasks/apache.yml
        - include: tasks/php.yml
        - include: tasks/mysql.yml
        - include: tasks/composer.yml
        - include: tasks/drush.yml
        - include: tasks/drupal.yml

All you need to do is create two new folders in the same folder where you saved the Drupal `playbook.yml` file, `handlers` and `tasks`, then create files inside for each section of the playbook.

For example, inside `handlers/handlers.yml`, you'd have, simply:

{lang="text"}
    ---
    - name: restart apache
      service: name=apache2 state=restarted

And inside `tasks/drush.yml`:

{lang="text"}
    ---
    - name: Check out drush master branch.
      git:
        repo: https://github.com/drush-ops/drush.git
        dest: /opt/drush
    
    - name: Install Drush dependencies with Composer."
      shell: >
        /usr/local/bin/composer install
        chdir=/opt/drush
        creates=/opt/drush/vendor/autoload.php
    
    - name: Create drush bin symlink.
      file:
        src: /opt/drush/drush
        dest: /usr/local/bin/drush
        state: link

Separating all the tasks into separate includes files means you'll have more files to manage for your playbook, but it helps keep the main playbook more compact (meaning it's easier to see all the installation and configuration steps the playbook contains), and also separates tasks into individual, easily-maintainable groupings. Instead of having to browse one playbook with twenty-three separate tasks, you now maintain eight included files with two to five tasks, each.

It's much easier to maintain a more granular set of plays than one very long playbook. However, there's no reason to try to *start* writing a playbook with lots of individual includes. Most of the time, it's best to start with a monolithic playbook while you're working on the setup and configuration details, then move sets of tasks out to included files after you start seeing logical groupings.

You can also use tags (demonstrated in the previous chapter) to limit the playbook run to a certain include file. Using the above example, if you wanted to add a 'drush' tag to the included drush file (so you could run `ansible-playbook playbook.yml --tags=drush` and only run the drush tasks), you can change line 20 to the following:

{lang=text,starting-line-number=20}
    - include: tasks/drush.yml tags=drush

T> You can find the entire example Drupal LAMP server playbook using include files in this book's code repository at [https://github.com/geerlingguy/ansible-for-devops](https://github.com/geerlingguy/ansible-for-devops), in the `includes` directory.

W> You can't use variables for task include file names (like you could with `include_vars` directives, e.g. `include_vars: "{{ ansible_os_family }}.yml"` as a task, or with `vars_files`). There's usually a better way than conditional task includes to accomplish conditional task inclusion using a different playbook structure, or roles, which we will discuss next.

## Roles

Including playbooks inside other playbooks makes your playbook organization a little more sane, but once you start wrapping up your entire infrastructure's configuration in playbooks, you might end up with something resembling Russian nesting dolls.

Wouldn't it be nice if there were a way to take bits of related configuration, and package them together nicely? Additionally, what if we could take these packages (often configuring the same thing on many different servers) and make them flexible so we can use the same package throughout our infrastructure, with slightly different settings on individual servers or groups of servers?

Ansible Roles can do all that, and more!

Let's dive into what makes an Ansible role by taking one of the playbook examples from Chapter 4 and splitting it into a more flexible structure using roles.

### Role scaffolding

Instead of requiring you to explicitly include certain files and playbooks in a role, Ansible automatically includes any `main.yml` files inside specific directories that make up the role.

There are only two directories required to make a working Ansible role:

{lang=text,linenos=off}
    role_name
      --> meta
      --> tasks

If you create a directory structure like the one shown above, with a `main.yml` file in each directory, Ansible will run all the tasks defined in `tasks/main.yml` if you call the role from your playbook using the following syntax:

{lang=text}
    ---
    - hosts: all
      roles:
        - role_name

Your roles (each one as its own directory, where the directory name is used by Ansible as the name of the role) can live in a couple different places---in the default global Ansible role path (configurable in `/etc/ansible/ansible.cfg`), or in a 'roles' folder directly within the same directory as your main playbook file.

I> Another simple way to build the scaffolding for a role (complete with all the available options/directories, a README file, and a structure suitable for contributing the role to Ansible Galaxy (we'll get to Galaxy in a little bit!) so it can easily be shared), is to use the `ansible-galaxy init` command. Running the command will create an example role in the current working directory, which you can then modify to suit your needs.

### Building your first role

Let's jump right into cleaning up our Node.js server example from Chapter four, and break out one of the main parts of the configuration---installing Node.js and any npm modules we need for our server.

Create a `roles` folder in the same directory as your main `playbook.yml` file like we created in Chapter 4's first example, and inside that folder, create a new folder `nodejs` (which will be our role's name). Create two folders inside the `nodejs` role directory, `meta` and `tasks`.

Inside the `meta` folder, add a simple `main.yml` file with the following contents:

{lang=text}
    ---
    dependencies: []

The meta information for your role is defined in this file. In basic examples and simple roles, you just need to list any role dependencies (other roles that are required to be run before the current role can do its work), but you can add much more to this file to describe your role to Ansible and to Ansible Galaxy. We'll dive deeper into the meta information later. For now, save the file and head over to the `tasks` foler.

Create a `main.yml` file in this folder, and add the following contents (basically copying and pasting the configuration from the Chapter 4 example):

{lang=text}
    ---
    - name: Install Node.js (npm plus all its dependencies).
      yum: name=npm state=present enablerepo=epel
    
    - name: Install forever module (to run our Node.js app).
      npm: name=forever global=yes state=latest

The Node.js directory structure should now look like the following:

{lang=text}
    nodejs-app/
      app/
        app.js
        package.json
      playbook.yml
      roles/
        nodejs/
          meta/
            main.yml
          tasks/
            main.yml

You now have a complete Ansible role that you can use in your node.js server configuration playbook. Delete the Node.js app installation lines from the other project, and reformat the playbook so the other tasks run first (in a `pre_tasks:` section instead of `tasks:`), then the role is included, then the rest of the tasks (in the main `tasks:` section). Something like:

{lang=text,linenos="off"}
    pre_tasks:
      # EPEL/GPG setup, firewall configuration...
    
    roles:
      - nodejs
    
    tasks:
      # Node.js app deployment tasks...

I> You can view the full example of this playbook in the [ansible-for-devops code repository](https://github.com/geerlingguy/ansible-for-devops/blob/master/nodejs-role/playbook.yml).

Once you finish reformatting the main playbook, everything would run exactly the same during an `ansible-playbook`, with the exception of the tasks inside the `nodejs` role being prefixed with `nodejs | [Task name here]`.

This little bit of extra data shown during playbook runs is useful because it shows you from exactly what role tasks are being run, without you having to add in descriptions as part of the `name` values of the tasks.

Our role isn't all that helpful at this point, though, because it still does only one thing, and it's not really flexible enough to be used on other servers that might need different Node.js modules to be installed.

### More flexibility with role vars and defaults

To make our role more flexible, we can make it use a list of npm modules instead of a hardcoded value, then allow playbooks using the role to define what modules they want to use.

When running a role's tasks, Ansible picks up variables defined in a role's `vars/main.yml` file and `defaults/main.yml` (I'll get to the differences between the two later), but will allow your playbooks to override the defaults or other role-provided variables if you want.

Modify the `tasks/main.yml` file to use a list variable and iterate through the list to install as many packages as your playbook wants:

{lang=text}
    ---
    - name: Install Node.js (npm plus all its dependencies).
      yum: name=npm state=present enablerepo=epel
    
    - name: Install npm modules required by our app.
      npm: name={{ item }} global=yes state=latest
      with_items: node_npm_modules

Let's provide a sane default for the new `node_npm_modules` variable in `defaults/main.yml`:

{lang=text}
    ---
    node_npm_modules:
      - forever

Now, if you run the playbook as-is, it will still do the exact same thing---install the `forever` module. But since the role is more flexible, we could create a new playbook like our first, but add a variable (either in a `vars` section or in an included file via `vars_files`) to override the default, like so:

{lang=text}
    node_npm_modules:
      - forever
      - async
      - request

When you run the playbook with this custom variable (we didn't change *anything* with our `nodejs` role), all three of the above npm modules will be installed.

Hopefully you're beginning to see how this can be powerful!

Imagine if you had a playbook structure like:

{lang=text}
    ---
    - hosts: appservers
      roles:
        - yum-repo-setup
        - firewall
        - nodejs
        - app-deploy

Each one of the roles would live in its own isolated world, and could be shared with other servers and groups of servers in your infrastructure.

  - A `yum-repo-setup` role could enable certain repositories and import their GPG keys.
  - A `firewall` role could have per-server or per-inventory-group options for ports and services to allow or deny.
  - An `app-deploy` role could deploy your app to a directory (configurable per-server) and set certain app options per-server or per-group.

All these things become very easy to manage when you have small bits of functionality separated into different roles. Instead of managing 100+ lines of playbook tasks, and manually prefixing every `name:` with something like "Common |" or "App Deploy |", you now manage a few roles with 10-20 lines of YAML each.

On top of that, when you're building your main playbooks, they can be extremely simple (like the above example), enabling you to see *everything* being configured and deployed on a particular server without scrolling through dozens of included playbook files and hundreds of tasks.

T> **Variable precedence**: Note that Ansible handles variables placed in included files in `defaults` with less precedence than those placed in `vars`. If you have certain variables you need to allow hosts/playbooks to easily override, you should probably put them into `defaults`. If they are common variables that should almost always be the values defined in your role, put them into `vars`. For more on variable precedence, see the aptly-named "Variable Precedence" section in the previous chapter.

### Other role parts: handlers, files, and templates

#### Handlers

In one of the prior examples, we introduced handlers---tasks that could be called via the `notify` option after any playbook task resulted in a change---and an example handler for restarting Apache was given:

{lang=text}
    handlers:
      - name: restart apache
        service: name=apache2 state=restarted

In Ansible roles, handlers are first-class citizens, alongside tasks, variables, and other configuration. You can store handlers directly inside a `main.yml` file inside a role's `handlers` directory. So if we had a role for Apache configuration, our `handlers/main.yml` file could look like the following:

{lang=text}
    ---
    - name: restart apache
      command: service apache2 restart

You can call handlers defined in a role's handlers folder just like you would handlers included directly in your playbooks (e.g. `notify: restart apache`).

#### Files and Templates

For the following examples, let's assume our role is structured with files and templates inside `files` and `templates` directories, respectively:

{lang=text}
    roles/
      example/
        files/
          example.conf
        meta/
          main.yml
        templates/
          example.xml.j2
        tasks/
          main.yml

when copying a file directly to the server, add the filename or the full path from within a role's `files` directory, like so:

{lang="text",linenos="off"}
    - name: Copy configuration file to server directly.
      copy: >
        src=example.conf
        dest=/etc/myapp/example.conf
        mode=644

Similarly, when specifying a template, add the filename or the full path from within a role's `templates` directory, like so:

{lang="text",linenos="off"}
    - name: Copy configuration file to server using a template.
      template: >
        src=example.xml.j2
        dest=/etc/myapp/example.xml
        mode=644

The `copy` module simply copies files from within the module's `files` folder, and the `template` module runs given template files through the Jinja2 templating engine, merging in any variables available during your playbook run before copying the file to the server.

### Organizing more complex and cross-platform roles

For simple package installation and configuration roles, you can get by with placing all tasks, variables, and handlers directly in the respective `main.yml` file Ansible automatically loads. But you can also *include* other files from within a role's `main.yml` files if needed.

As a rule of thumb, I like to keep my playbook and role task files under 100 lines of YAML if at all possible (that way it's easier for me to keep the entire set of tasks in my head while working through any issues). If I start nearing that limit, I usually split the tasks into logical groupings, and include files from the `main.yml` file.

Let's take a look at the way my `geerlingguy.apache` role is set up (it's [available on Ansible Galaxy](https://galaxy.ansible.com/list#/roles/428) and can be downloaded to your roles directory with the command `ansible-galaxy install geerlingguy.apache`; we'll discuss Ansible Galaxy itself later).

Initially, the role's main `tasks/main.yml` file looked something like the following (generally speaking):

{lang=text}
    - name: Ensure Apache is installed (via apt).
    
    - name: Configure Apache with lineinfile.
    
    - name: Enable Apache modules.

Soon after creating the role, though, I wanted to make the role work with both Debian and RedHat hosts. I could've simply added two sets of tasks in the `main.yml` file, resulting in twice the number of plays and a bunch of extra `when` statements:

{lang=text}
    - name: Ensure Apache is installed (via apt).
      when: ansible_os_family == 'Debian'
    
    - name: Ensure Apache is installed (via yum).
      when: ansible_os_family == 'RedHat'
    
    - name: Configure Apache with lineinfile (Debian).
      when: ansible_os_family == 'Debian'
    
    - name: Configure Apache with lineinfile (Redhat).
      when: ansible_os_family == 'RedHat'
    
    - name: Enable Apache modules (Debian).
      when: ansible_os_family == 'Debian'
    
    - name: Other OS-agnostic tasks...

If I had gone this route, and continued with the rest of the playbook tasks in one file, I would've quickly surpassed my informal 100-line limit. So I chose to use includes in my main tasks file:

{lang=text}
    - name: Include OS-specific variables.
      include_vars: "{{ ansible_os_family }}.yml"
    
    - include: setup-RedHat.yml
      when: ansible_os_family == 'RedHat'
    
    - include: setup-Debian.yml
      when: ansible_os_family == 'Debian'
    
    - name: Other OS-agnostic tasks...

Two important things to notice about this style of distribution-specific inclusion:

  1. When including vars files (with `include_vars`), you can actually *use variables in the name of the file*. This is very handy for a variety of use cases, and here we're simply including a vars file in the format `distribution_name.yml`. For our purposes, since the role will be used on Debian and RedHat-based hosts, we can create `Debian.yml` and `RedHat.yml` files in our role's `defaults` and `vars` folders, and put distribution-specific variables there.
  2. When including playbook files (with `include`), you can't use variables in the name of the file, but you can do the next best thing: include the files by name explicitly, and use a condition to tell Ansible whether to run the tasks inside (the `when` condition will be applied to every task inside the included playbook).

After setting things up this way, I put RedHat and CentOS-specific tasks (like `yum` tasks) into `tasks/setup-RedHat.yml`, and Debian and Ubuntu-specific tasks (like `apt` tasks) into `tasks/setup-Debian.yml`. There are other ways of making roles work cross-platform, but using distribution-specific variables files and included playbooks is one of the simplest.

Now this Apache role can be used across different distributions, and with clever usage of variables in tasks and in configuration templates, it can be used in a very wide variety of infrastructure that needs Apache installed.

## Ansible Galaxy

Ansible roles are powerful and flexible; they allow you to encapsulate sets of configuration and deployable units of playbooks, variables, templates, and other files, so you can easily reuse them across different servers.

It's annoying to have to start from scratch every time, though; wouldn't it be better if people could share roles for commonly-installed applications and services? Enter [Ansible Galaxy](https://galaxy.ansible.com/).

Ansible Galaxy, or just 'Galaxy', is a repository of community-contributed roles for common Ansible content. There are already hundreds of roles available which can configure and deploy common applications, and they're all available through the `ansible-galaxy` command, introduced in Ansible 1.4.2.

Galaxy offers the ability to add, download, and rate roles, and you can register either using a social account or a normal account on the site (though you don't need an account to install and use roles from Galaxy).

### Getting roles from Galaxy

One of the primary functions of the `ansible-galaxy` command is retrieving roles from Galaxy. Roles must be downloaded before they can be used in playbooks.

Remember the basic LAMP (Linux, Apache, MySQL and PHP) server we installed earlier in the book? Let's create it again, but this time, using a few roles from Galaxy:

{lang="text",linenos="off"}
    $ ansible-galaxy install geerlingguy.apache geerlingguy.mysql geerlingguy.php

T> The latest version or a role will be downloaded if no version is specified. To specify a version, add the version after the role name, for example: `$ ansible-galaxy install geerlingguy.apache,1.0.0`.

I> Ansible Galaxy is still evolving rapidly, and has already seen many small improvements. There are a few areas where Galaxy could use some improvement (like browsing for roles by Operating System in the online interface, or automatically downloading roles that are included in playbooks), but most of these little bugs or rough areas will be fixed in time. Please check Ansible Galaxy's [About](https://galaxy.ansible.com/intro) page and stay tuned to Ansible's blog for the latest updates.

### A LAMP server in six lines of YAML

Now that we have these roles installed (Apache, MySQL, and PHP), we can quickly create a LAMP server. This example assumes you already have a CentOS-based linux VM or server booted and can connect to it or run Ansible as a provisioner via Vagrant on it, and that you've run the `ansible-galaxy install` command above to download the required roles.

First, create an Ansible playbook named `lamp.yml` with the following contents:

{lang="text"}
    ---
    - hosts: all
      roles:
        - geerlingguy.mysql
        - geerlingguy.apache
        - geerlingguy.php

Now, run the playbook against a host:

{lang="text",linenos="off"}
    $ ansible-playbook -i path/to/custom-inventory lamp.yml

After a few minutes, an entire LAMP server should be set up and running. If you add in a few variables, you can configure virtualhosts, PHP configuration options, MySQL server settings, etc.

We've effectively reduced about thirty lines of YAML (from previous examples dealing with LAMP or LAMP-like servers) down to three. Obviously, the roles have extra code in them, but the power here is in abstraction. Since most companies have many servers using similar software, but with slightly different configurations, having centralized, flexible roles saves a lot of repetition.

You could think of Galaxy roles (which typically install and configure common software like Apache or MySQL, or set up security rules or frameworks) as glorified packages; they not only install software, but they configure it *exactly* how you want it, every time, with minimal manual labor. Additionally, many of these roles work across different flavors of Linux and UNIX, so you have better configuration portability!

### A Solr server in six lines of YAML

Let's grab a few more roles and build an Apache Solr search server, which requires Java and Apache Tomcat to be installed and configured.

{lang="text",linenos="off"}
    $ ansible-galaxy install geerlingguy.java geerlingguy.tomcat6 geerlingguy.solr

Then create a playbook named `solr.yml` with the following contents:

{lang="text"}
    ---
    - hosts: all
      roles:
        - geerlingguy.java
        - geerlingguy.tomcat6
        - geerlingguy.solr

Now we have a fully-functional Solr server, and we could add some variables to configure it exactly how we want, by using a non-default port, or changing the memory allocation for Tomcat6.

I think you might get the point. Now, I could've also left out the `java` and `tomcat6` roles, since they'll be automatically picked up during installation of the `geerlingguy.solr` role (they're listed in the `solr` role's dependencies).

A role's page on the Ansible Galaxy website highlights available variables for setting things like what version of Solr to install, where to install it, etc. (as an example, view the [geerlingguy.solr Galaxy page](https://galaxy.ansible.com/list#/roles/445)).

Using community-maintained roles, you can build a wide variety of servers with minimal effort. Instead of having to maintain lengthy playbooks and roles unique to each server, Galaxy lets you build a list of the required roles, and a few variables that set up the servers with the proper versions and paths. Configuration management with Ansible Galaxy becomes *true* configuration management---you get to spend more time managing your server's configuration, and less time on packaging and building individual services!

### Helpful Galaxy commands

Some other helpful `ansible-galaxy` commands you might use from time to time:

  - `ansible-galaxy list` displays a list of installed roles, with version numbers
  - `ansible-galaxy remove [role]` removes an installed role
  - `ansible-galaxy init` can be used to create a role template suitable for submission to Ansible Galaxy

You can configure the default path where Ansible roles will be downloaded by editing your `ansible.cfg` configuration file (normally located in `/etc/ansible/ansible.cfg`), and setting a `roles_path` in the `[defaults]` section.

### Contributing to Ansible Galaxy

If you've been working on some useful Ansible roles, and you'd like to share them with others, all you need to do is make sure they follow Ansible Galaxy's basic template (especially within the `meta/main.yml` and `README.md` files). To get started, use `ansible-galaxy init` to generate a basic Galaxy template, and make your own role match the Galaxy template's structure.

Then push your role up to a new project on GitHub (I usually name my Galaxy roles like `ansible-role-[rolename]`, so I can easily see them when browsing my repos on GitHub), and add a new role while logged into galaxy.ansible.com.

## Summary

Using includes and Ansible roles organizes Playbooks and makes them maintainable. This chapter introduced different ways of using `include`, the power and flexible structure of roles, and how you can utilize Ansible Galaxy, the community repository of configurable Ansible roles that do just about anything.

{lang="text",linenos=off}
     _________________________________________
    / When the only tool you own is a hammer, \
    | every problem begins to resemble a      |
    \ nail. (Abraham Maslow)                  /
     -----------------------------------------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||
