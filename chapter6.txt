# Chapter 6 - Playbook Organization - Roles and Includes

So far, we've used fairly straightforward examples in this book. Most examples are ad-hoc for a particular server, and listing all tasks in one long listing makes for a fairly long playbook.

Ansible is very flexible when it comes to organizing your plays in more efficient ways so you can make your playbooks more maintainable, reusable, and powerful. We'll look at two ways to split up plays more efficiently: using includes and roles. Finally, we'll explore Ansible Galaxy, a repository of some community-maintained roles that help configure common packages and applications.

## Includes

We've already seen one of the most basic ways of including other files in Chatper 4, when `vars_files` was used to place variables into a separate `vars.yml` file instead of inline with the playbook:

{lang="text",linenos=off}
    - hosts: all
    
      vars_files:
      - vars.yml

Tasks can easily be included in a similar way. In the `tasks:` section of your playbook, you can add `include` directives like so:

{lang="text",linenos=off}
    tasks:
      - include: included-playbook.yml

Just like with variable include files, tasks are formatted in a flat list in the included file. As an example, the `included-playbook.yml` could look like:

{lang="text",linenos=off}
    ---
    - name: Add profile info for user.
      copy: >
        src=example_profile
        dest=/home/{{ username }}/.profile
        owner={{ username }} group={{ username }} mode=744
    
    - name: Add private keys for user.
      copy: >
        src={{ item.src }}
        dest=/home/.ssh/{{ item.dest }}
        owner={{ username }} group={{ username }} mode=600
      with_items: ssh_private_keys
    
    - name: Restart example service.
      service: name=example state=restarted

In this case, you'd probably want to name the file `user-config.yml`, since it's used to configure a user account and restart some service. Now, in this and any other playbook that provisions or configures a server, if you want to configure a particular user's account, add the following in your playbook's `tasks` section:

{lang="text",linenos=off}
    - include: example-app-config.yml

We used `{{ username }}` and `{{ ssh_private_keys }}` variables in this include file instead of hard-coded values so we could make this include file reusable. You could define the variables in your playbook's inline variables or an included variables file, but Ansible also lets you pass variables directly into includes using normal YAML syntax. For example:

{lang="text",linenos=off}
    - { include: user-config.yml, username: johndoe, ssh_private_keys: [] }
    - { include: user-config.yml, username: janedoe, ssh_private_keys: [] }

To make the syntax more readable, you can use structured variables, like so:

{lang="text",linenos=off}
    - include: user-config.yml
      vars:
        username: johndoe
        ssh_private_keys:
          - { src: /path/to/johndoe/key1, dest: id_rsa }
          - { src: /path/to/johndoe/key2, dest: id_rsa_2 }
    - include: user-config.yml
      vars:
        username: janedoe
        ssh_private_keys:
          - { src: /path/to/janedoe/key1, dest: id_rsa }
          - { src: /path/to/janedoe/key2, dest: id_rsa_2 }

Include files can even include other files, so you could have something like the following:

{lang="text",linenos=off}
    tasks:
      - include: user-config.yml

*inside `user-config.yml`*

{lang="text",linenos=off}
    - include: ssh-setup.yml

### Handler includes

Handlers can be included just like tasks, within a playbook's `handlers` section. For example:

{lang="text",linenos=off}
    handlers:
      - include: included-handlers.yml

This can be helpful in limiting the noise in your main playbook, since handlers are usually used for things like restarting services or loading a configuration, and can distract from the playbook's primary purpose.

### Playbook includes

Playbooks can even be included in other playbooks, by simply using the same `include` syntax in the top level of your playbook. For example, if you have two playbooksâ€”one to set up your webservers (`web.yml`), and one to set up your database servers (`db.yml`), you could use the following playbook to run both at the same time:

{lang="text",linenos=off}
    - hosts: all
      remote_user: root
      
      tasks:
        ...
      
    - include: web.yml
    - include: db.yml

This way, you can create playbooks to configure all the servers in your entire infrastructure, then create a master playbook that includes each of the individual playbooks. When you want to initialize your entire infrastructure, make changes across your entire fleet of servers, or just check to make sure their configuration matches your playbook definitions, you can run one `ansible-playbook` command!

### Complete includes example

What if I told you we could remake the 137-line Drupal LAMP server playbook from Chapter 4 in just 21 lines? With includes, it's easy; just break out each of the sets of tasks into their own include files, and you'll end up with a main playbook like this:

{lang="text"}
    ---
    - hosts: all
    
      vars_files:
        - vars.yml
    
      pre_tasks:
        - name: Update apt cache if needed.
          apt: update_cache=yes cache_valid_time=3600
    
      handlers:
        - include: handlers/handlers.yml
    
      tasks:
        - include: tasks/common.yml
        - include: tasks/apache.yml
        - include: tasks/php.yml
        - include: tasks/mysql.yml
        - include: tasks/composer.yml
        - include: tasks/drush.yml
        - include: tasks/drupal.yml

All you need to do is create two new folders in the same folder where you saved the Drupal `playbook.yml` file, `handlers` and `tasks`, then create files inside for each section of the playbook.

For example, inside `handlers/handlers.yml`, you'd have, simply:

{lang="text"}
    ---
    - name: restart apache
      command: service apache2 restart

And inside `tasks/drush.yml`:

{lang="text"}
    ---
    - name: "Check out drush master branch."
      git: repo=https://github.com/drush-ops/drush.git dest=/opt/drush
    
    - name: "Install Drush dependencies with Composer."
      shell: >
        /usr/local/bin/composer install
        chdir=/opt/drush
        creates=/opt/drush/vendor/autoload.php
    
    - name: "Create drush bin symlink."
      file: >
        src=/opt/drush/drush
        dest=/usr/local/bin/drush
        state=link

Separating all the tasks into separate includes files means you'll have more files to manage for your playbook, but it helps keep the main playbook more compact (meaning it's easier to see all the installation and configuration steps the playbook contains), and also separates tasks into individual, easily-maintainable groupings. Instead of having to browse one playbook with twenty-three separate tasks, you now maintain eight included files with two to five tasks, each.

It's much easier to maintain a more granular set of plays than one very long playbook. However, there's no reason to try to *start* writing a playbook with lots of individual includes. Most of the time, it's best to start with a monolithic playbook while you're working on the setup and configuration details, then move sets of tasks out to included files after you start seeing logical groupings.

TODO:

  - Add example including adding a tag to the include (so you can run just one set of instructions).

T> You can find the entire example Drupal LAMP server playbook using include files in this book's code repository at [https://github.com/geerlingguy/ansible-for-devops](https://github.com/geerlingguy/ansible-for-devops), in the `includes` directory.

W> You can't use variables for task include file names (like you could with `include_vars` directives, e.g. `include_vars: "{{ ansible_os_family }}.yml"` as a task, or with `vars_files`). There's usually a better way than conditional task includes to accomplish conditional task inclusion using a different playbook structure, or roles, which we will discuss next.

## Roles

Including playbooks inside other playbooks makes your playbook organization a little more sane, but once you start wrapping up your entire infrastructure's configuration in playbooks, you might end up with something resembling Russian nesting dolls.

Wouldn't it be nice if there were a way to take bits of related configuration, and package them together nicely? Additionally, what if we could take these packages (often configuring the same thing on many different servers) and make them flexible so we can use the same package throughout our infrastructure, with slightly different settings on individual servers or groups of servers?

Ansible Roles can do all that, and more!

Let's dive right into what makes an Ansible role by taking one of the playbook examples from Chapter 4 and splitting it into a more flexible structure using roles.

### Role scaffolding

Instead of requiring you to explicitly include certain files and playbooks in a role, Ansible automatically includes any `main.yml` files inside specific directories that make up the role.

There are only two directories required to make a working Ansible role:

{lang=text,linenos=off}
    role_name
      --> meta
      --> tasks

If you create a directory structure like the one shown above, with a `main.yml` file in each directory, Ansible will run all the tasks defined in `tasks/main.yml` if you call the role from your playbook using the following syntax:

{lang=text}
    ---
    - hosts: all
      roles:
        - role_name

Your roles (each one as it's own directory, where the directory name is used by Ansible as the name of the role) can live in a couple different places---in the default global Ansible role path (configurable in `/etc/ansible/ansible.cfg`), or in a 'roles' folder directly within the same directory as your main playbook file.

I> Another simple way to build the scaffolding for a role (complete with all the available options/directories, a README file, and a structure suitable for contributing the role to Ansible Galaxy (we'll get to Galaxy in a little bit!) so it can easily be shared), is to use the `ansible-galaxy init` command. Running the command will create an example role in the current working directory, which you can then modify to suit your needs.

### Building your first role

Let's jump right into cleaning up our Node.js server example from Chapter four, and break out one of the main parts of the configuration---installing Node.js and any npm modules we need for our server.

Create a `roles` folder in the same directory as your main `playbook.yml` file like we created in Chapter 4's first example, and inside that folder, create a new folder `nodejs` (which will be our role's name). Create two folders inside the `nodejs` role directory, `meta` and `tasks`.

Inside the `meta` folder, add a simple `main.yml` file with the following contents:

{lang=text}
    ---
    dependencies: []

The meta information for your role is defined in this file. In basic examples and simple roles, you just need to list any role dependencies (other roles that are required to be run before the current role can do its work), but you can add much more to this file to describe your role to Ansible and to Ansible Galaxy. We'll dive deeper into the meta information later. For now, save the file and head over to the `tasks` foler.

Create a `main.yml` file in this folder, and add the following contents (basically copying and pasting the configuration from the Chapter 4 example):

{lang=text}
    ---
    - name: Install Node.js (npm plus all it's dependencies).
      yum: pkg=npm state=present enablerepo=epel
    
    - name: Install forever module (to run our Node.js app).
      npm: name=forever global=yes state=latest

You now have a complete Ansible role that you can use in your node.js server configuration playbook. Delete the same lines from the other project, and reformat the playbook so the other tasks run first (in a `pre_tasks:` section instead of `tasks:`), then the role is included, then the rest of the tasks (in the main `tasks:` section). Something like:

{lang=text,linenos="off"}
    pre_tasks:
      # EPEL/GPG setup, firewall configuration...
    
    roles:
      - nodejs
    
    tasks:
      # Node.js app deployment tasks...

Once you have that done, you could run your playbook, and everything would run exactly the same during an `ansible-provision`, with the exception of the tasks inside the `nodejs` being prefixed with `nodejs | [Task name here]`.

This little bit of extra data shown during playbook runs is useful because it shows you from exactly what role tasks are being run, without you having to add in descriptions as part of the `name` values of the tasks.

Our role isn't all that helpful at this point, though, because it still does only one thing, and it's not really flexible enough to be used on other servers that might need different Node.js modules to be installed.

### More flexibility with role vars and defaults

To make our role more flexible, we can make it use a list of npm modules instead of a hardcoded value, then allow playbooks using the role to define what modules they want to use.

When running a role's tasks, Ansible picks up variables defined in a role's `vars/main.yml` file and `defaults/main.yml` (I'll get to the differences between the two later), but will allow your playbooks to override the defaults or other role-provided variables if you want.

Modify the `tasks/main.yml` file to use a list variable and iterate through the list to install as many packages as your playbook wants:

{lang=text}
    ---
    - name: Install Node.js (npm plus all it's dependencies).
      yum: pkg=npm state=present enablerepo=epel
    
    - name: Install npm modules required by our app.
      npm: name={{ item }} global=yes state=latest
      with_items: node_npm_modules

Let's provide a sane default for the new `node_npm_modules` variable in `defaults/main.yml`:

{lang=text}
    ---
    node_npm_modules:
      - forever

Now, if you run the playbook as-is, it will still do the exact same thing---install the `forever` module. But since the role is more flexible, we could create a new playbook like our first, but add a variable (either in a `vars` section or in an included file via `vars_files`) to override the default, like so:

{lang=text}
    node_npm_modules:
      - forever
      - async
      - request

When you run the playbook with this custom variable (we didn't change *anything* with our `nodejs` role), all three of the above npm modules will be installed.

Hopefully you're beginning to see how this can be very powerful!

Imagine if you had a playbook structure like:

{lang=text}
    ---
    - hosts: appservers
      roles:
        - yum-repo-setup
        - firewall
        - nodejs
        - app-deploy

Each one of the roles would live in its own isolated world, and could be shared with other servers and groups of servers in your infrastructure.

  - A `yum-repo-setup` role could enable certain repositories and import their GPG keys.
  - A `firewall` role could have options for ports and services to allow or deny.
  - An `app-deploy` role could deploy your app to a directory (configurable per-server) and set certain app options per server or group.

All these things become very easy to manage when you have small bits of functionality separated into different roles. Instead of managing 100+ lines of playbook tasks, and manually prefixing every `name:` with something like "Common |" or "App Deploy |", you now manage a few roles with 10-20 lines of YAML each.

On top of that, when you're building your main playbooks, they can be extremely simple (like the above example), enabling you to immediately see *everything* being configured and deployed on a particular server without scrolling through dozens of tasks.

T> **Variable precedence**: Note that Ansible handles variables placed in included files in `defaults` with less precedence than those placed in `vars`. If you have certain variables you need to allow hosts/playbooks to easily override, you should probably put them into `defaults`. If they are common variables that should almost always be the values defined in your role, put them into `vars`. For more on variable precedence, see the aptly-named "Variable Precedence" section in the previous chapter.

### Other role parts: handlers, files, and templates

TODO.

## Ansible Galaxy

Ansible roles are powerful and flexible; they allow you to encapsulate sets of configuration and deployable units of playbooks, variables, templates, and other files, so you can easily reuse them across different servers.

It's annoying to have to start from scratch every time, though; wouldn't it be better if people could share roles for commonly-installed applications and services? Enter [Ansible Galaxy](https://galaxy.ansible.com/).

Ansible Galaxy, or just 'Galaxy', is a repository of community-contributed roles for common Ansible content. There are already hundreds of roles available which can configure and deploy common applications, and they're all available through the `ansible-galaxy` command, introduced in Ansible 1.4.2.

Galaxy offers the ability to add, download, and rate roles, and you can register either using a social account or a normal account on the site (though you don't need an account to install and use roles from Galaxy).

### Getting roles from Galaxy

One of the primary functions of the `ansible-galaxy` command is retrieving roles from Galaxy. Roles must be downloaded before they can be used in playbooks.

Remember the basic LAMP (Linux, Apache, MySQL and PHP) server we installed earlier in the book? Let's create it again, but this time, using a few roles from Galaxy:

{lang="text",linenos="off"}
    $ ansible-galaxy install geerlingguy.apache geerlingguy.mysql geerlingguy.php

T> The latest version or a role will be downloaded if no version is specified. To specify a version, add the version after the role name, for example: `$ ansible-galaxy install geerlingguy.apache,1.0.0`.

I> Ansible Galaxy is still evolving rapidly, and has already seen many small improvements. There are a few areas where Galaxy could use some improvement (like browsing for roles by Operating System in the online interface, or automatically downloading roles that are included in playbooks), but most of these little bugs or rough areas will be fixed in time. Please check Ansible Galaxy's [About](https://galaxy.ansible.com/intro) page and stay tuned to Ansible's blog for the latest updates.

### A LAMP server in six lines of YAML

Now that we have these roles installed (Apache, MySQL, and PHP), we can quickly create a LAMP server. This example assumes you already have a CentOS-based linux VM or server booted and can connect to it or run Ansible as a provisioner via Vagrant on it, and that you've run the `ansible-galaxy install` command above to download the required roles.

First, create an Ansible playbook named `lamp.yml` with the following contents:

{lang="text"}
    ---
    - hosts: all
      roles:
        - geerlingguy.mysql
        - geerlingguy.apache
        - geerlingguy.php

Now, run the playbook against a host:

{lang="text",linenos="off"}
    $ ansible-playbook -i path/to/custom-inventory lamp.yml

After a few minutes, an entire LAMP server should be set up and running. If you add in a few variables, you can configure virtualhosts, PHP configuration options, MySQL server settings, etc.

We've effectively reduced about thirty lines of YAML (from previous examples dealing with LAMP or LAMP-like servers) down to three. Obviously, the roles have extra code in them, but the power here is in abstraction. Since most companies have many servers using similar software, but with slightly different configurations, having centralized, flexible roles saves a lot of repetition.

You could think of Galaxy roles (which typically install common software like Apache or MySQL) as glorified packages; they not only install software, but they configure it *exactly* how you want it, every time, with minimal manual labor. Additionally, many of these roles work across different flavors of Linux and UNIX, so you have better configuration portability!

### A Solr server in six lines of YAML

Let's grab a few more roles and build an Apache Solr search server, which requires Java and Apache Tomcat to be installed and configured.

{lang="text",linenos="off"}
    $ ansible-galaxy install geerlingguy.java geerlingguy.tomcat6 geerlingguy.solr

Then create a playbook named `solr.yml` with the following contents:

{lang="text"}
    ---
    - hosts: all
      roles:
        - geerlingguy.java
        - geerlingguy.tomcat6
        - geerlingguy.solr

Now we have a fully-functional Solr server, and we could add some variables to configure it exactly how we want, by using a non-default port, or changing the memory allocation for Tomcat6.

I think you might get the point. Now, I could've also left out the `java` and `tomcat6` roles, since they'll be automatically picked up during installation of the `geerlingguy.solr` role (they're listed in the `solr` role's dependencies).

A role's page on the Ansible Galaxy website highlights available variables for setting things like what version of Solr to install, where to install it, etc. (as an example, view the [geerlingguy.solr Galaxy page](https://galaxy.ansible.com/list#/roles/445)).

Using community-maintained roles, you can build a wide variety of servers with minimal effort. Instead of having to maintain lengthy playbooks and roles unique to each server, Galaxy lets you build a list of the required roles, and a few variables that set up the servers with the proper versions and paths. Configuration management with Ansible Galaxy becomes *true* configuration management---you get to spend more time managing your server's configuration, and less time on packaging and building individual services!

### Helpful Galaxy commands

Some other helpful `ansible-galaxy` commands you might use from time to time:

  - `ansible-galaxy list` displays a list of installed roles, with version numbers
  - `ansible-galaxy remove [role]` removes an installed role
  - `ansible-galaxy init` can be used to create a role template suitable for submission to Ansible Galaxy

You can configure the default path where Ansible roles will be downloaded by editing your `ansible.cfg` configuration file (normally located in `/etc/ansible/ansible.cfg`), and setting a `roles_path` in the `[defaults]` section.

### Contributing to Ansible Galaxy

If you've been working on some useful Ansible roles, and you'd like to share them with others, all you need to do is make sure they follow Ansible Galaxy's basic template (especially within the `meta/main.yml` and `README.md` files). To get started, use `ansible-galaxy init` to generate a basic Galaxy template, and make your own role match the Galaxy template's structure.

Then push your role up to a new project on GitHub (I usually name my Galaxy roles like `ansible-role-[rolename]`, so I can easily see them when browsing my repos on GitHub), and add a new role while logged into galaxy.ansible.com.

## Summary

TODO.

{lang="text",linenos=off}
     _________________________________________
    / When the only tool you own is a hammer, \
    | every problem begins to resemble a      |
    \ nail. (Abraham Maslow)                  /
     -----------------------------------------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||
