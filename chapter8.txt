# Chapter 8 - Ansible Cookbooks

Until now, most of this book has demonstrated individual aspects of Ansible---inventory, playbooks, ad-hoc tasks, etc. But this chapter synthesizes everything we've gone over in the previous chapters and shows how Ansible is applied to real-world infrastructure management scenarios.

## Highly-Available Infrastructure with Ansible

Real-world web applications require redundancy and horizontal scalability with multi-server infrastructure. In the following example, we'll use Ansible to configure a complex infrastructure on servers provisioned either locally (via Vagrant and VirtualBox) or on a set of automatically-provisioned instances (running on either DigitalOcean or Amazon Web Services):

{width=60%}
![Highly-Available Infrastructure.](images/8-highly-available-infrastructure.png)

**Varnish** acts as a load balancer and reverse proxy, fronting web requests and routing them to the application servers. We could just as easily use something like **Nginx** or **HAProxy**, or even a proprietary cloud-based solution like an Amazon's **Elastic Load Balancer** or Linode's **NodeBalancer**, but for simplicity's sake and for flexibility in deployment, we'll use Varnish.

**Apache** and mod_php run a PHP-based application that displays the entire stack's current status and outputs the current server's IP address for load balancing verification.

A **Memcached** server provides a caching layer that can be used to store and retrieve frequently-accessed objects in lieu of slower database storage.

Two **MySQL** servers, configured as a master and slave, offer redundant and performant database access; all data will be replicated from the master to the slave, and in addition, the slave can be used as a secondary server for read-only queries to take some load off the master.

### Directory Structure

In order to keep our configuration organized, we'll use the following structure for our playbooks and configuration:

{lang="text",linenos=off}
    lamp-infrastructure/
      inventories/
      playbooks/
        db/
        memcached/
        varnish/
        www/
      provisioners/
      configure.yml
      provision.yml
      requirements.yml
      Vagrantfile

Organizing things this way allows us to focus on each server configuration individually, then build playbooks for provisioning and configuring instances on different hosting providers later. This organization also keeps server playbooks completely independent, so we can modularize and reuse individual server configurations.

### Individual Server Playbooks

Let's start building our individual server playbooks (in the `playbooks` directory). To make our playbooks more efficient, we'll use some contributed Ansible roles on Ansible Galaxy rather than install and configure everything step-by-step. We're going to target CentOS 6.x servers in these playbooks, but only minimal changes would be required to use the playbooks with Ubuntu, Debian, or later versions of CentOS.

**Varnish**

Create a `main.yml` file within the the `playbooks/varnish` directory, with the following contents:

{lang="text"}
    ---
    - hosts: lamp-varnish
      become: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.repo-epel
        - geerlingguy.varnish
    
      tasks:
        - name: Copy Varnish default.vcl.
          template:
            src: "templates/default.vcl.j2"
            dest: "/etc/varnish/default.vcl"
          notify: restart varnish

We're going to run this playbook on all hosts in the `lamp-varnish` inventory group (we'll create this later), and we'll run a few simple roles to configure the server:

  - `geerlingguy.firewall` configures a simple iptables-based firewall using a couple variables defined in `vars.yml`.
  - `geerlingguy.repo-epel` adds the EPEL repository (a prerequisite for varnish).
  - `geerlingguy.varnish` installs and configures Varnish.

Finally, a task copies over a custom `default.vcl` that configures Varnish, telling it where to find our web servers and how to load balance requests between the servers.

Let's create the two files referenced in the above playbook. First, `vars.yml`, in the same directory as `main.yml`:

{lang="text"}
    ---
    firewall_allowed_tcp_ports:
      - "22"
      - "80"
    
    varnish_use_default_vcl: false

The first variable tells the `geerlingguy.firewall` role to open TCP ports 22 and 80 for incoming traffic. The second variable tells the `geerlingguy.varnish` we will supply a custom `default.vcl` for Varnish configuration.

Create a `templates` directory inside the `playbooks/varnish` directory, and inside, create a `default.vcl.j2` file. This file will use Jinja2 syntax to build Varnish's custom `default.vcl` file:

{lang="text"}
    vcl 4.0;
    
    import directors;
    
    {% for host in groups['lamp-www'] %}
    backend www{{ loop.index }} {
      .host = "{{ host }}";
      .port = "80";
    }
    {% endfor %}
    
    sub vcl_init {
      new vdir = directors.random();
    {% for host in groups['lamp-www'] %}
      vdir.add_backend(www{{ loop.index }}, 1);
    {% endfor %}
    }
    
    sub vcl_recv {
      set req.backend_hint = vdir.backend();
    
      # For testing ONLY; makes sure load balancing is working correctly.
      return (pass);
    }

We won't study Varnish's VCL syntax in depth but we'll run through `default.vcl` and highlight what is being configured:

  1. (1-3) Indicate that we're using the 4.0 version of the VCL syntax and import the `directors` varnish module (which is used to configure load balancing).
  2. (5-10) Define each web server as a new backend; give a host and a port through which varnish can contact each host.
  3. (12-17) `vcl_init` is called when Varnish boots and initializes any required varnish modules. In this case, we're configuring a load balancer `vdir`, and adding each of the `www[#]` backends we defined earlier as backends to which the load balancer will distribute requests. We use a `random` director so we can easily demonstrate Varnish's ability to distribute requests to both app backends, but other load balancing strategies are also available.
  4. (19-24) `vcl_recv` is called for each request, and routes the request through Varnish. In this case, we route the request to the `vdir` backend defined in `vcl_init`, and indicate that Varnish should *not* cache the result.

According to #4, we're actually *bypassing Varnish's caching layer*, which is not helpful in a typical production environment. If you only need a load balancer without any reverse proxy or caching capabilities, there are better options. However, we need to verify our infrastructure is working as it should. If we used Varnish's caching, Varnish would only ever hit one of our two web servers during normal testing.

In terms of our caching/load balancing layer, this should suffice. For a true production environment, you should remove the final `return (pass)` and customize `default.vcl` according to your application's needs.

**Apache / PHP**

Create a `main.yml` file within the the `playbooks/www` directory, with the following contents:

{lang="text"}
    ---
    - hosts: lamp-www
      become: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.repo-epel
        - geerlingguy.apache
        - geerlingguy.php
        - geerlingguy.php-mysql
        - geerlingguy.php-memcached
    
      tasks:
        - name: Remove the Apache test page.
          file:
            path: /var/www/html/index.html
            state: absent
        - name: Copy our fancy server-specific home page.
          template:
            src: templates/index.php.j2
            dest: /var/www/html/index.php

As with Varnish's configuration, we'll configure a firewall and add the EPEL repository (required for PHP's memcached integration), and we'll also add the following roles:

  - `geerlingguy.apache` installs and configures the latest available version of the Apache web server.
  - `geerlingguy.php` installs and configures PHP to run through Apache.
  - `geerlingguy.php-mysql` adds MySQL support to PHP.
  - `geerlingguy.php-memcached` adds Memcached support to PHP.

Two final tasks remove the default `index.html` home page included with Apache, and replace it with our PHP app.

As in the Varnish example, create the two files referenced in the above playbook. First, `vars.yml`, alongside `main.yml`:

{lang="text"}
    ---
    firewall_allowed_tcp_ports:
      - "22"
      - "80"

Create a `templates` directory inside the `playbooks/www` directory, and inside, create an `index.php.j2` file. This file will use Jinja2 syntax to build a (relatively) simple PHP script to display the health and status of all the servers in our infrastructure:

{lang=php}
    <?php
    /**
     * @file
     * Infrastructure test page.
     *
     * DO NOT use this in production. It is simply a PoC.
     */
    
    $mysql_servers = array(
    {% for host in groups['lamp-db'] %}
      '{{ host }}',
    {% endfor %}
    );
    $mysql_results = array();
    foreach ($mysql_servers as $host) {
      if ($result = mysql_test_connection($host)) {
        $mysql_results[$host] = '<span style="color: green;">PASS\
    </span>';
        $mysql_results[$host] .= ' (' . $result['status'] . ')';
      }
      else {
        $mysql_results[$host] = '<span style="color: red;">FAIL</span>';
      }
    }
    
    // Connect to Memcached.
    $memcached_result = '<span style="color: red;">FAIL</span>';
    if (class_exists('Memcached')) {
      $memcached = new Memcached;
      $memcached->addServer('{{ groups['lamp-memcached'][0] }}', 11211);
    
      // Test adding a value to memcached.
      if ($memcached->add('test', 'success', 1)) {
        $result = $memcached->get('test');
        if ($result == 'success') {
          $memcached_result = '<span style="color: green;">PASS</span>';
          $memcached->delete('test');
        }
      }
    }
    
    /**
     * Connect to a MySQL server and test the connection.
     *
     * @param string $host
     *   IP Address or hostname of the server.
     *
     * @return array
     *   Array with 'success' (bool) and 'status' ('slave' or 'master').
     *   Empty if connection failure.
     */
    function mysql_test_connection($host) {
      $username = 'mycompany_user';
      $password = 'secret';
      try {
        $db = new PDO(
          'mysql:host=' . $host . ';dbname=mycompany_database',
          $username,
          $password,
          array(PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION));
    
        // Query to see if the server is configured as a master or slave.
        $statement = $db->prepare("SELECT variable_value
          FROM information_schema.global_variables
          WHERE variable_name = 'LOG_BIN';");
        $statement->execute();
        $result = $statement->fetch();
    
        return array(
          'success' => TRUE,
          'status' => ($result[0] == 'ON') ? 'master' : 'slave',
        );
      }
      catch (PDOException $e) {
        return array();
      }
    }
    ?>
    <!DOCTYPE html>
    <html>
    <head>
      <title>Host {{ inventory_hostname }}</title>
      <style>* { font-family: Helvetica, Arial, sans-serif }</style>
    </head>
    <body>
      <h1>Host {{ inventory_hostname }}</h1>
      <?php foreach ($mysql_results as $host => $result): ?>
        <p>MySQL Connection (<?php print $host; ?>): 
        <?php print $result; ?></p>
      <?php endforeach; ?>
      <p>Memcached Connection: <?php print $memcached_result; ?></p>
    </body>
    </html>

T> Don't try transcribing this example manually; you can get the code from this book's repository on GitHub. Visit the [ansible-for-devops](https://github.com/geerlingguy/ansible-for-devops) repository and download the source for [index.php.j2](https://github.com/geerlingguy/ansible-for-devops/blob/master/lamp-infrastructure/playbooks/www/templates/index.php.j2)

As this is the heart of the example application we're deploying to the infrastructure, it's necessarily a bit more complex than most examples in the book, but a quick run through follows:

  - (9-23) Iterate through all the `lamp-db` MySQL hosts defined in the playbook inventory and test the ability to connect to them---as well as whether they are configured as master or slave, using the `mysql_test_connection()` function defined later (40-73).
  - (25-39) Check the first defined `lamp-memcached` Memcached host defined in the playbook inventory, confirming the ability to connect with the cache and to create, retrieve, or delete a cached value.
  - (41-76) Define the `mysql_test_connection()` function, which tests the the ability to connect to a MySQL server and also returns its replication status.
  - (78-91) Print the results of all the MySQL and Memcached tests, along with `{{ inventory_hostname }}` as the page title, so we can easily see which web server is serving the viewed page.

At this point, the heart of our infrastructure---the application that will test and display the status of all our servers---is ready to go.

**Memcached**

Compared to the earlier playbooks, the Memcached playbook is quite simple. Create `playbooks/memcached/main.yml` with the following contents:

{lang="text"}
    ---
    - hosts: lamp-memcached
      become: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.memcached

As with the other servers, we need to ensure only the required TCP ports are open using the simple `geerlingguy.firewall` role. Next we install Memcached using the `geerlingguy.memcached` role.

In our `vars.yml` file (again, alongside `main.yml`), add the following:

{lang="text"}
    ---
    firewall_allowed_tcp_ports:
      - "22"
    firewall_additional_rules:
      - "iptables -A INPUT -p tcp --dport 11211 -s \
      {{ groups['lamp-www'][0] }} -j ACCEPT"
      - "iptables -A INPUT -p tcp --dport 11211 -s \
      {{ groups['lamp-www'][1] }} -j ACCEPT"
    
    memcached_listen_ip: "{{ groups['lamp-memcached'][0] }}"

We need port 22 open for remote access, and for Memcached, we're adding manual iptables rules to allow access on port 11211 for the web servers *only*. We add one rule per `lamp-www` server by drilling down into each item in the the generated `groups` variable that Ansible uses to track all inventory groups currently available. We also bind Memcached to the server's IP address so it will accept connections through IP.

W> The **principle of least privilege** "requires that in a particular abstraction layer of a computing environment, every module ... must be able to access only the information and resources that are necessary for its legitimate purpose" (Source: [Wikipedia](http://en.wikipedia.org/wiki/Principle_of_least_privilege)). Always restrict services and ports to only those servers or users that need access!

**MySQL**

The MySQL configuration is more complex than the other servers because we need to configure MySQL users per-host and configure replication. Because we want to maintain an independent and flexible playbook, we also need to dynamically create some variables so MySQL will get the right server addresses in any potential environment.

Let's first create the main playbook, `playbooks/db/main.yml`:

{lang="text"}
    ---
    - hosts: lamp-db
      become: yes
    
      vars_files:
        - vars.yml
    
      pre_tasks:
        - name: Create dynamic MySQL variables.
          set_fact:
            mysql_users:
              - name: mycompany_user
                host: "{{ groups['lamp-www'][0] }}"
                password: secret
                priv: "*.*:SELECT"
              - name: mycompany_user
                host: "{{ groups['lamp-www'][1] }}"
                password: secret
                priv: "*.*:SELECT"
            mysql_replication_master: "{{ groups['a4d.lamp.db.1'][0] }}"
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.mysql

Most of the playbook is straightforward, but in this instance, we're using `set_fact` as a `pre_task` (to be run before the `geerlingguy.firewall` and `geerlingguy.mysql` roles) to dynamically create variables for MySQL configuration.

`set_fact` allows us to define variables at runtime, so we can are guaranteed to have all server IP addresses available, even if the servers were freshly provisioned at the beginning of the playbook's run. We'll create two variables:

  - `mysql_users` is a list of users the `geerlingguy.mysql` role will create when it runs. This variable will be used on all database servers so both of the two `lamp-www` servers get `SELECT` privileges on all databases.
  - `mysql_replication_master` is used to indicate to the `geerlingguy.mysql` role which database server is the master; it will perform certain steps differently depending on whether the server being configured is a master or slave, and ensure that all the slaves are configured to replicate data from the master.

We'll need a few other normal variables to configure MySQL, so we'll add them alongside the firewall variable in `playbooks/db/vars.yml`:

{lang="text"}
    ---
    firewall_allowed_tcp_ports:
      - "22"
      - "3306"
    
    mysql_replication_user: {name: 'replication', password: 'secret'}
    mysql_databases:
      - name: mycompany_database
        collation: utf8_general_ci
        encoding: utf8

We're opening port 3306 to anyone, but according to the **principle of least privilege** discussed earlier, you would be justified in restricting this port to only the servers and users that need access to MySQL (similar to the memcached server configuration). In this case, the attack vector is mitigated because MySQL's own authentication layer is used through the `mysql_user` variable generated in `main.yml`.

We are defining two MySQL variables: `mysql_replication_user` to be used for master and slave replication, and `mysql_databases` to define a list of databases that will be created (if they don't already exist) on the database servers.

With the configuration of the database servers complete, the server-specific playbooks are ready to go.

### Main Playbook for Configuring All Servers

A simple playbook including each of the group-specific playbooks is all we need for the overall configuration to take place. Create `configure.yml` in the project's root directory, with the following contents:

{lang="text"}
    ---
    - include: playbooks/varnish/main.yml
    - include: playbooks/www/main.yml
    - include: playbooks/db/main.yml
    - include: playbooks/memcached/main.yml

At this point, if you had some already-booted servers and statically defined inventory groups like `lamp-www`, `lamp-db`, etc., you could run `ansible-playbook configure.yml` and have a full HA infrastructure at the ready!

But we're going to continue to make our playbooks more flexible and useful.

### Getting the required roles

As mentioned in the Chapter 6, Ansible allows you to define all the required Ansible Galaxy roles for a given project in a `requirements.yml` file. Instead of having to remember to run `ansible-galaxy install -y [role1] [role2] [role3]` for each of the roles we're using, we can create `requirements.yml` in the root of our project, with the following contents:

{lang="text"}
    ---
    - src: geerlingguy.firewall
    - src: geerlingguy.repo-epel
    - src: geerlingguy.varnish
    - src: geerlingguy.apache
    - src: geerlingguy.php
    - src: geerlingguy.php-mysql
    - src: geerlingguy.php-memcached
    - src: geerlingguy.mysql
    - src: geerlingguy.memcached

To make sure all the required dependencies are installed, run `ansible-galaxy install -r requirements.yml` from within the project's root.

### Vagrantfile for Local Infrastructure via VirtualBox

As with many other examples in this book, we can use Vagrant and VirtualBox to build and configure the infrastructure locally. This lets us test things as much as we want with zero cost, and usually results in faster testing cycles, since everything is orchestrated over a local private network on a (hopefully) beefy workstation.

Our basic Vagrantfile layout will be something like the following:

  1. Define a base box (in this case, CentOS 6.x) and VM hardware defaults.
  2. Define all the VMs to be built, with VM-specific IP addresses and hostname configurations.
  3. Define the Ansible provisioner along with the last VM, so Ansible can run once at the end of Vagrant's build cycle.

Here's the Vagrantfile in all its glory:

{lang=ruby}
    # -*- mode: ruby -*-
    # vi: set ft=ruby :
    
    Vagrant.configure("2") do |config|
      # Base VM OS configuration.
      config.vm.box = "geerlingguy/centos6"
      config.ssh.insert_key = false
    
      # General VirtualBox VM configuration.
      config.vm.provider :virtualbox do |v|
        v.memory = 512
        v.cpus = 1
        v.linked_clone = true
        v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        v.customize ["modifyvm", :id, "--ioapic", "on"]
      end
    
      # Varnish.
      config.vm.define "varnish" do |varnish|
        varnish.vm.hostname = "varnish.dev"
        varnish.vm.network :private_network, ip: "192.168.2.2"
      end
    
      # Apache.
      config.vm.define "www1" do |www1|
        www1.vm.hostname = "www1.dev"
        www1.vm.network :private_network, ip: "192.168.2.3"
    
        www1.vm.provision "shell",
          inline: "sudo yum update -y"
    
        www1.vm.provider :virtualbox do |v|
          v.customize ["modifyvm", :id, "--memory", 256]
        end
      end
    
      # Apache.
      config.vm.define "www2" do |www2|
        www2.vm.hostname = "www2.dev"
        www2.vm.network :private_network, ip: "192.168.2.4"
    
        www2.vm.provision "shell",
          inline: "sudo yum update -y"
    
        www2.vm.provider :virtualbox do |v|
          v.customize ["modifyvm", :id, "--memory", 256]
        end
      end
    
      # MySQL.
      config.vm.define "db1" do |db1|
        db1.vm.hostname = "db1.dev"
        db1.vm.network :private_network, ip: "192.168.2.5"
      end
    
      # MySQL.
      config.vm.define "db2" do |db2|
        db2.vm.hostname = "db2.dev"
        db2.vm.network :private_network, ip: "192.168.2.6"
      end
    
      # Memcached.
      config.vm.define "memcached" do |memcached|
        memcached.vm.hostname = "memcached.dev"
        memcached.vm.network :private_network, ip: "192.168.2.7"
    
        # Run Ansible provisioner once for all VMs at the end.
        memcached.vm.provision "ansible" do |ansible|
          ansible.playbook = "configure.yml"
          ansible.inventory_path = "inventories/vagrant/inventory"
          ansible.limit = "all"
          ansible.extra_vars = {
            ansible_ssh_user: 'vagrant',
            ansible_ssh_private_key_file: \
    "~/.vagrant.d/insecure_private_key"
          }
        end
      end
    end

Most of the Vagrantfile is straightforward, and similar to other examples used in this book. The last block of code, which defines the `ansible` provisioner configuration, contains three extra values that are important for our purposes:

{lang=ruby}
          ansible.inventory_path = "inventories/vagrant/inventory"
          ansible.limit = "all"
          ansible.extra_vars = {
            ansible_ssh_user: 'vagrant',
            ansible_ssh_private_key_file: \
    "~/.vagrant.d/insecure_private_key"
          }

  1. `ansible.inventory_path` defines an inventory file to be used with the `ansible.playbook`. You could certainly create a dynamic inventory script for use with Vagrant, but because we know the IP addresses ahead of time, and are expecting a few specially-crafted inventory group names, it's simpler to build the inventory file for Vagrant provisioning by hand (we'll do this next).
  2. `ansible.limit` is set to `all` so Vagrant knows it should run the Ansible playbook connected to all VMs, and not just the current VM. You could technically use `ansible.limit` with a provisioner configuration for each of the individual VMs, and just run the VM-specific playbook through Vagrant, but our live production infrastructure will be using one playbook to configure all the servers, so we'll do the same locally.
  3. `ansible.extra_vars` contains the vagrant SSH user configuration for Ansible. It's more standard to include these settings in a static inventory file or use Vagrant's automatically-generated inventory file, but it's easiest to set them once for all servers here.

Before running `vagrant up` to see the fruits of our labor, we need to create an inventory file for Vagrant at `inventories/vagrant/inventory`:

{lang="text"}
    [lamp-varnish]
    192.168.2.2
    
    [lamp-www]
    192.168.2.3
    192.168.2.4
    
    [a4d.lamp.db.1]
    192.168.2.5
    
    [lamp-db]
    192.168.2.5
    192.168.2.6
    
    [lamp-memcached]
    192.168.2.7

Now `cd` into the project's root directory, run `vagrant up`, and after ten or fifteen minutes, load `http://192.168.2.2/` in your browser. Voila!

{width=80%}
![Highly Available Infrastructure - Success!](images/8-ha-infrastructure-success.png)

You should see something like the above screenshot. The PHP app displays the current app server's IP address, the individual MySQL servers' status, and the Memcached server status. Refresh the page a few times to verify Varnish is distributing requests randomly between the two app servers.

We now have local infrastructure development covered, and Ansible makes it easy to use the exact same configuration to build our infrastructure in the cloud.

### Provisioner Configuration: DigitalOcean

In Chapter 7, we learned provisioning and configuring DigitalOcean droplets in an Ansible playbook is fairly simple. But we need to take provisioning a step further by provisioning multiple droplets (one for each server in our infrastructure) and dynamically grouping them so we can configure them after they are booted and online.

For the sake of flexibility, let's create a playbook for our DigitalOcean droplets in `provisioners/digitalocean.yml`. This will allow us to add other provisioner configurations later, alongside the `digitalocean.yml` playbook. As with our example in Chapter 7, we will use a local connection to provision cloud instances. Begin the playbook with:

{lang="text"}
    ---
    - hosts: localhost
      connection: local
      gather_facts: false

Next we need to define some metadata to describe each of our droplets. For simplicity's sake, we'll inline the `droplets` variable in this playbook:

{lang="text",starting-line-number=6}
      vars:
        droplets:
          - { name: a4d.lamp.varnish, group: "lamp-varnish" }
          - { name: a4d.lamp.www.1, group: "lamp-www" }
          - { name: a4d.lamp.www.2, group: "lamp-www" }
          - { name: a4d.lamp.db.1, group: "lamp-db" }
          - { name: a4d.lamp.db.2, group: "lamp-db" }
          - { name: a4d.lamp.memcached, group: "lamp-memcached" }

Each droplet is an object with two keys:

  - `name`: The name of the Droplet for DigitalOcean's listings and Ansible's host inventory.
  - `group`: The Ansible inventory group for the droplet.

Next we need to add a task to create the droplets, using the `droplets` list as a guide, and as part of the same task, register each droplet's information in a separate dictionary, `created_droplets`:

{lang="text",starting-line-number=15}
      tasks:
        - name: Provision DigitalOcean droplets.
          digital_ocean:
            state: "{{ item.state | default('present') }}"
            command: droplet
            name: "{{ item.name }}"
            private_networking: yes
            size_id: "{{ item.size | default(66) }}" # 512mb
            image_id: "{{ item.image | default(6372108) }}" # CentOS 6
            region_id: "{{ item.region | default(4) }}" # NYC2
            ssh_key_ids: "{{ item.ssh_key | default('138954') }}"
            unique_name: yes
          register: created_droplets
          with_items: droplets

Many of the options (e.g. `size_id`) are defined as `{{ item.property | default('default_value') }}`, which allows us to use optional variables per droplet. For any of the defined droplets, we could add `size_id: 72` (or another valid value), and it would override the default value set in the task.

T> You could specify an SSH public key per droplet, or use the same key for all hosts by providing a default (as I did above). In this example, I added an SSH key to my DigitalOcean account, then used the DigitalOcean API to retrieve the key's numeric ID (as described in the previous chapter).
T> 
T> It's best to use key-based authentication and add at least one SSH key to your DigitalOcean account so Ansible can connect using secure keys instead of insecure passwords---especially since these instances will be created with only a root account.

We loop through all the defined `droplets` using `with_items: droplets`, and after each droplet is created, we add the droplet's metadata (name, IP address, etc.) to the `created_droplets` variable. Next, we'll loop through that variable to build our inventory on-the-fly so our configuration applies to the correct servers:

{lang="text",starting-line-number=30}
        - name: Add DigitalOcean hosts to inventory groups.
          add_host:
            name: "{{ item.1.droplet.ip_address }}"
            groups: "do,{{ droplets[item.0].group }},\
    {{ item.1.droplet.name }}"
            # You can dynamically add inventory variables per-host.
            ansible_ssh_user: root
            mysql_replication_role: >
              "{{ 'master' if (item.1.droplet.name == 'a4d.lamp.db.1')
              else 'slave' }}"
            mysql_server_id: "{{ item.0 }}"
          when: item.1.droplet is defined
          with_indexed_items: created_droplets.results

You'll notice a few interesting things happening in this task:

  - This is the first time we've used `with_indexed_items`. Though less common, this is a valuable loop feature because it adds a sequential and unique `mysql_server_id`. Though only the MySQL servers need a server ID set, it's more simple to dynamically create the variable for every server so each is available when needed. `with_indexed_items` sets `item.0` to the key of the item and `item.1` to the value of the item.
  - In addition to helping us create server IDs, `with_indexed_items` also helps us to reliably set each droplet's group. Because the v1 DigitalOcean API doesn't support features like tags for Droplets, we have to set up the groups on our own. By using the `droplets` variable we manually created earlier, we can set the proper group for a particular droplet.
  - Finally, we add inventory variables per-host in `add_host`. To do this, we add the variable name as a key and the variable value as that key's value. Simple, but powerful!

T> There are a few different ways you can approach dynamic provisioning and inventory management for your infrastructure. There are ways to avoid using more exotic features of Ansible (e.g. `with_indexed_items`) and complex if/else conditions, especially if you only use one cloud infrastructure provider. This example is slightly more complex because the playbook is being created to be interchangeable with similar provisioning playbooks.

The final step in our provisioning is to make sure all the droplets are booted and can be reached via SSH. So at the end of the `digitalocean.yml` playbook, add another play to be run on hosts in the `do` group we just defined:

{lang="text",starting-line-number=43}
    - hosts: do
      remote_user: root
      gather_facts: no

      tasks:
        - name: Wait for port 22 to become available.
          local_action: "wait_for port=22 host={{ inventory_hostname }}"

Once we know port 22 is reachable, we know the droplet is up and ready for configuration.

We're now *almost* ready to provision and configure our entire infrastructure on DigitalOcean, but first we need to create one last playbook to tie everything together. Create `provision.yml` in the project root with the following contents:

{lang="text"}
    ---
    - include: provisioners/digitalocean.yml
    - include: configure.yml

That's it! Now, assuming you set the environment variables `DO_CLIENT_ID` and `DO_API_KEY`, you can run `$ ansible-playbook provision.yml` to provision and configure the infrastructure on DigitalOcean.

The entire process should take about 15 minutes; once it's complete, you should see something like this:

{lang="text",linenos=off}
    PLAY RECAP **********************************************************
    107.170.27.137       : ok=19   changed=13   unreachable=0    failed=0
    107.170.3.23         : ok=13   changed=8    unreachable=0    failed=0
    107.170.51.216       : ok=40   changed=18   unreachable=0    failed=0
    107.170.54.218       : ok=27   changed=16   unreachable=0    failed=0
    162.243.20.29        : ok=24   changed=15   unreachable=0    failed=0
    192.241.181.197      : ok=40   changed=18   unreachable=0    failed=0
    localhost            : ok=2    changed=1    unreachable=0    failed=0

Visit the IP address of the varnish server, and you will be greeted with a status page similar to the one generated by the Vagrant-based infrastructure:

{width=80%}
![Highly Available Infrastructure on DigitalOcean.](images/8-ha-infrastructure-digitalocean.png)

Because everything in this playbook is idempotent, running `$ ansible-playbook provision.yml` again should report no changes, and this will help you verify that everything is running correctly.

Ansible will also rebuild and reconfigure any droplets that might be missing from your infrastructure. If you're daring and would like to test this feature, just log into your DigitalOcean account, delete one of the droplets just created by this playbook (perhaps one of the two app servers), and then run the playbook again.

Now that we've tested our infrastructure on DigitalOcean, we can destroy the droplets just as easily as we can create them. To do this, change the `state` parameter in `provisioners/digitalocean.yml` to default to `'absent'` and run `$ ansible-playbook provision.yml` once more.

Next up, we'll build the infrastructure a third time---on Amazon's infrastructure.

### Provisioner Configuration: Amazon Web Services (EC2)

For Amazon Web Services, provisioning is slightly different. Amazon has a broader ecosystem of services surrounding EC2 instances, so for our particular example we will need to configure security groups prior to provisioning instances.

To begin, create `aws.yml` inside the `provisioners` directory and begin the playbook the same way as for DigitalOcean:

{lang="text"}
    ---
    - hosts: localhost
      connection: local
      gather_facts: false

EC2 instances use security groups as an AWS-level firewall (which operates outside the individual instance's OS).
We will need to define a list of `security_groups` alongside our EC2 `instances`. First, the `instances`:

{lang="text",starting-line-number=6}
      vars:
        instances:
          - name: a4d.lamp.varnish
            group: "lamp-varnish"
            security_group: ["default", "a4d_lamp_http"]
          - name: a4d.lamp.www.1
            group: "lamp-www"
            security_group: ["default", "a4d_lamp_http"]
          - name: a4d.lamp.www.2
            group: "lamp-www"
            security_group: ["default", "a4d_lamp_http"]
          - name: a4d.lamp.db.1
            group: "lamp-db"
            security_group: ["default", "a4d_lamp_db"]
          - name: a4d.lamp.db.2
            group: "lamp-db"
            security_group: ["default", "a4d_lamp_db"]
          - name: a4d.lamp.memcached
            group: "lamp-memcached"
            security_group: ["default", "a4d_lamp_memcached"]

Inside the `instances` variable, each instance is an object with three keys:

  - `name`: The name of the instance, which we'll use to tag the instance and ensure only one instance is created per name.
  - `group`: The Ansible inventory group in which the instance should belong.
  - `security_group`: A list of security groups into which the instance will be placed. The `default` security group is added to your AWS account upon creation, and has one rule to allow outgoing traffic on any port to any IP address.

I> If you use AWS exclusively, it would be best to autoscaling groups and change the design of this infrastructure a bit. For this example, we just need to ensure that the six instances we explicitly define are created, so we're using particular `name`s and an `exact_count` to enforce the 1:1 relationship.

With our instances defined, we'll next define a `security_groups` variable containing all the required security group configuration for each server:

{lang="text",starting-line-number=27}
        security_groups:
          - name: a4d_lamp_http
            rules:
              - proto: tcp
                from_port: 80
                to_port: 80
                cidr_ip: 0.0.0.0/0
              - proto: tcp
                from_port: 22
                to_port: 22
                cidr_ip: 0.0.0.0/0
            rules_egress: []
    
          - name: a4d_lamp_db
            rules:
              - proto: tcp
                from_port: 3306
                to_port: 3306
                cidr_ip: 0.0.0.0/0
              - proto: tcp
                from_port: 22
                to_port: 22
                cidr_ip: 0.0.0.0/0
            rules_egress: []
    
          - name: a4d_lamp_memcached
            rules:
              - proto: tcp
                from_port: 11211
                to_port: 11211
                cidr_ip: 0.0.0.0/0
              - proto: tcp
                from_port: 22
                to_port: 22
                cidr_ip: 0.0.0.0/0
            rules_egress: []

Each security group has a `name` (which was used to identify the security group in the `instances` list), `rules` (a list of firewall rules---like protocol, ports, and IP ranges---to limit *incoming* traffic), and `rules_egress` (a list of firewall rules to limit *outgoing* traffic).

We need three security groups: `a4d_lamp_http` to open port 80, `a4d_lamp_db` to open port 3306, and `a4d_lamp_memcached` to open port 11211.

Now that we have all the data we need to set up security groups and instances, our first task is to create or verify the existence of the security groups:

{lang="text",starting-line-number=64}
      tasks:
        - name: Configure EC2 Security Groups.
          ec2_group:
            name: "{{ item.name }}"
            description: Example EC2 security group for A4D.
            region: "{{ item.region | default('us-west-2') }}" # Oregon
            state: present
            rules: "{{ item.rules }}"
            rules_egress: "{{ item.rules_egress }}"
          with_items: security_groups

The `ec2_group` requires a name, region, and rules for each security group. Security groups will be created if they don't exist, modified to match the supplied values if they do exist, or verified if they both exist and match the given values.

With the security groups configured, we can provision the defined EC2 instances by looping through `instances` with the `ec2` module:

{lang="text",starting-line-number=75}
        - name: Provision EC2 instances.
          ec2:
            key_name: "{{ item.ssh_key | default('jeff_mba_home') }}"
            instance_tags:
              inventory_group: "{{ item.group | default('') }}"
              inventory_host: "{{ item.name | default('') }}"
            group: "{{ item.security_group | default('') }}"
            instance_type: "{{ item.type | default('t2.micro')}}" # Free
            image: "{{ item.image | default('ami-11125e21') }}" # RHEL6
            region: "{{ item.region | default('us-west-2') }}" # Oregon
            wait: yes
            wait_timeout: 500
            exact_count: 1
            count_tag:
              inventory_group: "{{ item.group | default('') }}"
              inventory_host: "{{ item.name | default('') }}"
          register: created_instances
          with_items: instances

This example is slightly more complex than the DigitalOcean example, and a few parts warrant a deeper look:

  - EC2 allows SSH keys to be defined by name---in my case, I have a key `jeff_mba_home` in my AWS account. You should set the `key_name` default to a key that you have in your account.
  - Instance tags are tags that AWS will attach to your instance, for categorization purposes. By giving a list of keys and values, I can then use that list later in the `count_tag` parameter.
  - `t2.micro` was used as the default instance type, since it falls within EC2's free tier usage. If you just set up an account and keep all AWS resource usage within free tier limits, you won't be billed anything.
  - `exact_count` and `count_tag` work together to ensure AWS provisions only one of each of the instances we defined. The `count_tag` tells the `ec2` module to match the given group + host and then `exact_count` tells the module to only provision `1` instance. If you wanted to *remove* all your instances, you could set `exact_count` to 0 and run the playbook again.

Each provisioned instance will have its metadata added to the registered `created_instances` variable, which we will use to build Ansible inventory groups for the server configuration playbooks.

{lang="text",starting-line-number=94}
        - name: Add EC2 instances to inventory groups.
          add_host:
            name: "{{ item.1.tagged_instances.0.public_ip }}"
            groups: "aws,{{ item.1.item.group }},{{ item.1.item.name }}"
            # You can dynamically add inventory variables per-host.
            ansible_ssh_user: ec2-user
            mysql_replication_role: >
              {{ 'master' if (item.1.item.name == 'a4d.lamp.db.1')
              else 'slave' }}
            mysql_server_id: "{{ item.0 }}"
          when: item.1.instances is defined
          with_indexed_items: created_instances.results

This `add_host` example is slightly simpler than the one for DigitalOcean, because AWS attaches metadata to EC2 instances which we can re-use when building groups or hostnames (e.g. `item.1.item.group`). We don't have to use list indexes to fetch group names from the original `instances` variable.

We still use `with_indexed_items` so we can use the index to generate a unique ID per server for use in building the MySQL master-slave replication.

The final steps in provisioning the EC2 instances are to ensure we can connect to them, and to set `selinux` into permissive mode so the configuration we supply will work correctly.

{lang="text",starting-line-number=107}
    # Run some general configuration on all AWS hosts.
    - hosts: aws
      gather_facts: false
    
      tasks:
        - name: Wait for port 22 to become available.
          local_action: "wait_for port=22 host={{ inventory_hostname }}"
    
        - name: Set selinux into 'permissive' mode.
          selinux: policy=targeted state=permissive
          become: yes

Since we defined `ansible_ssh_user` as `ec2-user` in the dynamically-generated inventory above, we need to ensure the `selinux` task runs explicitly with `sudo` by adding `become: yes`.

Now, modify the `provision.yml` file in the root of the project folder and change the provisioners include to look like the following:

{lang="text"}
    ---
    - include: provisioners/aws.yml
    - include: configure.yml

Assuming the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are set in your current terminal session, you can run `$ ansible-playbook provision.yml` to provision and configure the infrastructure on AWS.

The entire process should take about 15 minutes, and once it's complete, you should see something like this:

{lang="text",linenos=off}
    PLAY RECAP **********************************************************
    54.148.100.44        : ok=24   changed=16   unreachable=0    failed=0
    54.148.120.23        : ok=40   changed=19   unreachable=0    failed=0
    54.148.41.134        : ok=40   changed=19   unreachable=0    failed=0
    54.148.56.137        : ok=13   changed=9    unreachable=0    failed=0
    54.69.160.32         : ok=27   changed=17   unreachable=0    failed=0
    54.69.86.187         : ok=19   changed=14   unreachable=0    failed=0
    localhost            : ok=3    changed=1    unreachable=0    failed=0

Visit the IP address of the Varnish server, and you will be greeted with a status page similar to the one generated by the Vagrant and DigitalOcean-based infrastructure:

{width=80%}
![Highly Available Infrastructure on AWS EC2.](images/8-ha-infrastructure-aws.png)

As with the earlier examples, running `ansible-playbook provision.yml` again should produce no changes, because everything in this playbook is idempotent. If one of your instances was somehow terminated, running the playbook again would recreate and reconfigure the instance in a few minutes.

To terminate all the provisioned instances, you can change the `exact_count` in the `ec2` task to `0`, and run `$ ansible-playbook provision.yml` again.

### Summary

In the above example, an entire highly-available PHP application infrastructure was defined in a series of short Ansible playbooks, and then provisioning configuration was created to build the infrastructure on either local VMs, DigitalOcean droplets, or AWS EC2 instances.

Once you start working on building infrastructure this way---by abstracting individual servers, then abstracting cloud provisioning---you'll start to see some of Ansible's true power of being more than just a configuration management tool. Imagine being able to create your own multi-datacenter, multi-provider infrastructure with Ansible and some basic configuration.

Amazon, DigitalOcean, Rackspace and other hosting providers have their own tooling and unique infrastructure merits. However, building infrastructure in a provider-agnostic fashion provides the agility and flexibility that allow you to treat hosting providers as commodities, and gives you the freedom to build more reliable and more performant application infrastructure.

Even if you plan on running everything within one hosting provider's network (or in a private cloud, or even on a few bare metal servers), Ansible provides deep stack-specific integration so you can do whatever you need to do and manage the provider's services within your playbooks.

I> You can find the entire contents of this example in the [Ansible for DevOps GitHub repository](https://github.com/geerlingguy/ansible-for-devops), in the `lamp-infrastructure` directory.

## ELK Logging with Ansible

Though application, database, and backup servers may be some of the most mission-critical components of a well-rounded infrastructure, one area that is equally important is a decent logging system.

In the old days when one or two servers could handle an entire website or application, you could work with built-in logfiles and rsyslog to troubleshoot issues or check trends in performance, errors, or overall traffic. With a typical modern infrastructure---like the example above, with six separate servers---it pays dividends to find a better solution for application, server, and firewall/authentication logging. Plain text files, logrotate, and grep don't cut it anymore.

Among various modern logging and reporting toolsets, the 'ELK' stack (Elasticsearch, Logstash, and Kibana) has come to the fore as one of the best-performing and easiest-to-configure open source centralized logging solutions.

{width=80%}
![An example Kibana logging dashboard.](images/8-elk-kibana-example.png)

In our example, we'll configure a single ELK server to handle aggregation, searching, and graphical display of logged data from a variety of other servers, and give some common configuration examples to send common system logs, webserver logs, etc.

### ELK Playbook

Just like our previous example, we're going to let a few roles from Ansible Galaxy do the heavy lifting of actually installing and configuring Elasticsearch, Logstash, and Kibana. If you're interested in reading through the roles that do this work, feel free to peruse them after they've been downloaded.

In this example, I'm going to highlight the important parts rather than walk through each role and variable in detail. Then I'll show how you can use this base server to aggregate logs, then how to point your other servers' log files to it using Logstash Forwarder.

Here's our main playbook, saved as `provisioning/elk/playbook.yml`:

{lang="text"}
    - hosts: logs
      gather_facts: yes
    
      vars_files:
        - vars/main.yml
    
      pre_tasks:
        - name: Update apt cache if needed.
          apt: update_cache=yes cache_valid_time=86400
    
      roles:
        - geerlingguy.java
        - geerlingguy.nginx
        - geerlingguy.elasticsearch
        - geerlingguy.elasticsearch-curator
        - geerlingguy.kibana
        - geerlingguy.logstash
        - geerlingguy.logstash-forwarder

This assumes you have a `logs` group in your inventory with at least one server listed. The playbook includes a vars file located in `provisioning/elk/vars/main.yml`, so create that file, and then put the following inside:

{lang="text"}
    ---
    java_packages:
      - openjdk-7-jdk
    
    nginx_user: www-data
    nginx_worker_connections: 1024
    nginx_remove_default_vhost: true
    
    kibana_server_name: logs
    kibana_username: kibana
    kibana_password: password
    
    logstash_monitor_local_syslog: false
    logstash_forwarder_files:
      - paths:
          - /var/log/auth.log
        fields:
          type: syslog

You'll want to use something other than 'password' for `kibana_password`. Other options are straightforward, with the exception of the two `logstash_*` variables.

The first variable tells the `geerlingguy.logstash` role to ignore the local syslog file, because in this case, we're only interested in logging authorization attempts through the local `auth.log`.

The second variable gives the `geerlingguy.logstash-forwarder` role a list of files to monitor, along with metadata to tell logstash what kind of file is being monitored. In this case, we are only worried about the `auth.log` file, and we know it's a syslog-style file. (Logstash needs to know what kind of file you're monitoring so it can parse the logged messages correctly).

If you want to get this ELK server up and running quickly, you can create a local VM using Vagrant like you have in most other examples in the book. Create a `Vagrantfile` in the same directory as the `provisioning` folder, with the following contents:

{lang=ruby}
    # -*- mode: ruby -*-
    # vi: set ft=ruby :
    
    VAGRANTFILE_API_VERSION = "2"
    
    Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
      config.vm.box = "geerlingguy/ubuntu1204"
    
      config.vm.provider :virtualbox do |v|
        v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        v.customize ["modifyvm", :id, "--memory", 1024]
        v.customize ["modifyvm", :id, "--cpus", 2]
        v.customize ["modifyvm", :id, "--ioapic", "on"]
      end
    
      # ELK server.
      config.vm.define "logs" do |logs|
        logs.vm.hostname = "logs"
        logs.vm.network :private_network, ip: "192.168.9.90"
    
        logs.vm.provision :ansible do |ansible|
          ansible.playbook = "provisioning/elk/playbook.yml"
          ansible.inventory_path = "provisioning/elk/inventory"
          ansible.sudo = true
        end
      end
    
    end

This Vagrant configuration expects an inventory file at `provisioning/elk/inventory`, so quickly create one with the following contents:

{lang="text"}
    logs ansible_ssh_host=192.168.9.90 ansible_ssh_port=22

Now, run `vagrant up`. The build should take about five minutes, and upon completion, if you add a line like `logs  192.168.9.90` to your `/etc/hosts` file, you can visit `http://logs/` in your browser and see Kibana's default homepage:

{width=80%}
![Kibana's default homepage.](images/8-elk-kibana-default.png)

Kibana helpfully links to an example dashboard for Logstash (under the "Are you a Logstash User?" section), and if you select it, you should see a live dashboard that shows logged activity for the past day:

{width=80%}
![Kibana's default Logstash dashboard.](images/8-elk-kibana-logstash-dashboard.png)

In this example, we won't dive too deep into customizing Kibana's dashboard customization, since there are many guides to using Kibana available freely, including [Kibana's official guide](http://www.elasticsearch.org/guide/en/kibana/current/index.html). For our purposes, we'll use the default dashboard.

I> This example uses Kibana 3.x, but a stable release of Kibana 4.x is on the horizon (as of early 2015). Some of the screenshots may show a different interface than the latest release, but this book will likely be updated with newer screenshots and updated guides once the 4.x release comes out.

### Forwarding Logs from Other Servers

It's great that we have the ELK stack running. Elasticsearch will store and make available log data with one search index per day, Logstash will listen for log entries, Logstash Forwarder will send entries in `/var/log/auth.log` to Logstash, and Kibana will organize the logged data in useful visualizations.

Configuring additional servers to direct their logs to our new Logstash server is fairly simple using Logstash Forwarder. The basic steps we'll follow are:

  1. Set up another server in the Vagrantfile.
  2. Set up an Ansible playbook to install and configure Logstash Forwarder alongside the application running on the server.
  3. Boot the server and watch as the logs are forwarded to the main ELK server.

Let's begin by creating a new Nginx web server. (It's useful to monitor webserver access logs for a variety of reasons, especially to watch for traffic spikes and increases in non-200 responses for certain resources.) Add the following server definition inside the Vagrantfile, just after the `end` of the ELK server definition:

{lang=ruby,starting-line-number=28}
      # Web server.
      config.vm.define "webs" do |webs|
        webs.vm.hostname = "webs"
        webs.vm.network :private_network, ip: "192.168.9.91"

        webs.vm.provision :ansible do |ansible|
          ansible.playbook = "provisioning/web/playbook.yml"
          ansible.inventory_path = "provisioning/web/inventory"
          ansible.sudo = true
        end
      end

We'll next set up the simple playbook to install and configure both Nginx and Logstash Forwarder, at `provisioning/web/playbook.yml`:

{lang="text"}
    - hosts: webs
      gather_facts: yes
    
      vars_files:
        - vars/main.yml
    
      pre_tasks:
        - name: Update apt cache if needed.
          apt: update_cache=yes cache_valid_time=86400
    
      roles:
        - geerlingguy.nginx
        - geerlingguy.logstash-forwarder
    
      tasks:
        - name: Set up virtual host for testing.
          copy:
            src: files/example.conf
            dest: /etc/nginx/conf.d/example.conf
            owner: root
            group: root
            mode: 0644
          notify: restart nginx

This playbook installs the `geerlingguy.nginx` and `geerlingguy.logstash-forwarder` roles, and in the `tasks`, there is an additional task to configure one virtualhost in a Nginx configuration directory, via the file `example.conf`. Create that file now at the path `provisioning/web/files/example.conf`, and define one Nginx virtualhost for our testing:

{lang="text"}
    server {
      listen 80 default_server;
    
      root /usr/share/nginx/www;
      index index.html index.htm;
    
      access_log /var/log/nginx/access.log combined;
      error_log /var/log/nginx/error.log debug;
    }

Since this is the only `server` definition, and it's set as the `default_server` on port 80, all requests will be directed to it. We routed the `access_log` to `/var/log/nginx/access.log`, and told Nginx to write log entries using the `combined` format, which is how our Logstash server will expect nginx access logs to be formatted.

Next, set up the required variables to tell the `nginx` and `logstash-forwarder` roles how to configure their respective services. Inside `provisioning/web/vars/main.yml`:

{lang="text"}
    ---
    nginx_user: www-data
    nginx_worker_connections: 1024
    nginx_remove_default_vhost: true
    
    logstash_forwarder_logstash_server: 192.168.9.90
    logstash_forwarder_logstash_server_port: 5000
    
    logstash_forwarder_files:
      - paths:
          - /var/log/secure
        fields:
          type: syslog
      - paths:
          - /var/log/nginx/access.log
        fields:
          type: nginx

The `nginx` variables remove the default virtualhost entry and ensure Nginx will run optimally on our Ubuntu server. The `logstash_forwarder` variables tell `geerlingguy.logstash-forwarder` what logs to forward to our central log server:

  - `logstash_forwarder_logstash_server` and `_port`: Defines the server IP or domain and port to which logs should be transported.
  - `logstash_forwarder_files`: Defines a list of `paths` and `fields`, which identify a file or list of files to be transported to the log server, along with a `type` for the files. In this case, the authentication log (`/var/log/secure`) is a `syslog`-formatted log file, and `/var/log/nginx/access.log` is of type `nginx` (which will be parsed correctly on the Logstash server since it's in the combined log format popularized by Apache).

W> Note that this demonstration configuration does not use a custom certificate to authenticate logging connections. You should normally configure your own secure certificate and give the logstash-forwarder role the path to the certificate using the `logstash_forwarder_ssl_certificate_file` variable. If you use the example provided with the project, you could expose your logging infrastructure to the outside, and you'll get a `***SECURITY RISK***` warning in the logs every time the Logstash role is run.

To allow Vagrant to pass the proper connection details to Ansible, create `provisioning/web/inventory` with the `webs` host details:

{lang="text"}
    webs ansible_ssh_host=192.168.9.91 ansible_ssh_port=22

Run `vagrant up` again. Vagrant should verify that the first server (`logs`) is running, then create and run the Ansible provisioner on the newly-defined `webs` Nginx server.

You can load `http://192.168.9.91/` or `http://webs/` in your browser, and you should see a `Welcome to nginx!` message on the page. You can refresh the page a few times, then switch back over to `http://logs/` to view some new log entries on the ELK server:

{width=80%}
![Entries populating the Logstash Search Kibana dashboard.](images/8-logstash-forwarding-nginx.png)

T> If you refresh the page a few times, and no entries show up in the Kibana Logstash dashboard, it could be that Nginx is buffering the log entries. In this case, keep refreshing a while (so you generate a few dozen or hundred entries), and Nginx will eventually write the entries to disk (thus allowing Logstash Forwarder to convey the logs to the Logstash server). Read more about Nginx log buffering in the [Nginx's ngx_http_log_module documentation](http://nginx.org/en/docs/http/ngx_http_log_module.html).

A few requests being logged through logstash forwarder isn't all that exciting. Let's use the popular `ab` tool available most anywhere to put some load on the web server. On a modest MacBook Air, running the command below resulted in Nginx serving around 1,200 requests per second.

{lang="text",linenos=off}
    ab -n 20000 -c 50 http://webs/

During the course of the load test, I set Kibana to show only the past 5 minutes of log data (automatically refreshed every 5 seconds) and I could monitor the requests on the ELK server just a few seconds after they were served by Nginx:

{width=80%}
![Monitoring a deluge of Nginx requests in near-realtime.](images/8-logstash-forwarding-ab-load.png)

Logstash Forwarder uses a highly-efficient TCP-like protocol, Lumberjack, to transmit log entries securely between servers. With the right tuning and scaling, you can efficiently process and display thousands of requests per second across your infrastructure! For most, even the simple example demonstrated above would adequately cover an entire infrastructure's logging and log analysis needs.

### Summary

Log aggregation and analysis are two fields that see constant improvements and innovation. There are many SaaS products and proprietary solutions that can assist with logging, but few match the flexibility, security, and TCO of Elasticsearch, Logstash and Kibana.

Ansible is the simplest way to configure an ELK server and direct all your infrastructure's pertinent log data to the server.

## GlusterFS Distributed File System Configuration with Ansible

Modern infrastructure often involves some amount of horizontal scaling; instead of having one giant server with one storage volume, one database, one application instance, etc., most apps use two, four, ten, or dozens of servers.

{width=80%}
![GlusterFS is a distributed filesystem for servers.](images/8-glusterfs-architecture.png)

Many applications can be scaled horizontally with ease. But what happens when you need shared resources, like files, application code, or other transient data, to be shared on all the servers? And how do you have this data scale out with your infrastructure, in a fast but reliable way? There are many different approaches to synchronizing or distributing files across servers:

  - Set up rsync either on cron or via inotify to synchronize smaller sets of files on a regular basis.
  - Store everything in a code repository (e.g. Git, SVN, etc.) and deploy files to each server using Ansible.
  - Have one large volume on a file server and mount it via NFS or some other file sharing protocol.
  - Have one master SAN that's mounted on each of the servers.
  - Use a distributed file system, like Gluster, Lustre, Fraunhofer, or Ceph.

Some options are easier to set up than others, and all have benefits---and drawbacks. Rsync, git, or NFS offer simple initial setup, and low impact on filesystem performance (in many scenarios). But if you need more flexibility and scalability, less network overhead, and greater fault tolerance, you will have to consider something that requires more configuration (e.g. a distributed file system) and/or more hardware (e.g. a SAN).

GlusterFS is licensed under the AGPL license, has good documentation, and a fairly active support community (especially in the #gluster IRC channel). But to someone new to distributed file systems, it can be daunting to get set it up the first time.

### Configuring Gluster - Basic Overview

To get Gluster working on a basic two-server setup (so you can have one folder synchronized and replicated across the two servers---allowing one server to go down completely, and the other to still have access to the files), you need to do the following:

  1. Install Gluster server and client on each server, and start the server daemon.
  2. (On both servers) Create a 'brick' directory (where Gluster will store files for a given volume).
  3. (On both servers) Create a directory to be used as a mount point (a directory where you'll have Gluster mount the shared volume).
  4. (On both servers) Use `gluster peer probe` to have Gluster connect to the other server.
  5. (On one server) Use `gluster volume create` to create a new Gluster volume.
  6. (On one server) Use `gluster volume start` to start the new Gluster volume.
  7. (On both servers) Mount the gluster volume (adding a record to `/etc/fstab` to make the mount permanent).

Additionally, you need to make sure you have the following ports open on both servers (so Gluster can communicate): TCP ports 111, 24007-24011, 49152-49153, and UDP port 111. For each extra server in your Gluster cluster, you need to add an additional TCP port in the 49xxx range.

### Configuring Gluster with Ansible

For demonstration purposes, we'll set up a simple two-server infrastructure using Vagrant, and create a shared volume between the two, with two replicas (meaning all files will be replicated on each server). As your infrastructure grows, you can set other options for data consistency and transport according to your needs.

To build the two-server infrastructure locally, create a folder `gluster` containing the following `Vagrantfile`:

{lang=ruby}
    # -*- mode: ruby -*-
    # vi: set ft=ruby :
    
    Vagrant.configure("2") do |config|
      # Base VM OS configuration.
      config.vm.box = "geerlingguy/ubuntu1404"
      config.vm.synced_folder '.', '/vagrant', disabled: true
      config.ssh.insert_key = false
    
      config.vm.provider :virtualbox do |v|
        v.memory = 256
        v.cpus = 1
      end
    
      # Define two VMs with static private IP addresses.
      boxes = [
        { :name => "gluster1", :ip => "192.168.29.2" },
        { :name => "gluster2", :ip => "192.168.29.3" }
      ]
    
      # Provision each of the VMs.
      boxes.each do |opts|
        config.vm.define opts[:name] do |config|
          config.vm.hostname = opts[:name]
          config.vm.network :private_network, ip: opts[:ip]
    
          # Provision both VMs using Ansible after the last VM is booted.
          if opts[:name] == "gluster2"
            config.vm.provision "ansible" do |ansible|
              ansible.playbook = "playbooks/provision.yml"
              ansible.inventory_path = "inventory"
              ansible.limit = "all"
            end
          end
        end
      end
    
    end

This configuration creates two servers, `gluster1` and `gluster2`, and will run a playbook at `playbooks/provision.yml` on the servers defined in an `inventory` file in the same directory as the Vagrantfile.

Create the `inventory` file to help Ansible connect to the two servers:

{lang="text"}
    [gluster]
    192.168.29.2
    192.168.29.3
    
    [gluster:vars]
    ansible_ssh_user=vagrant
    ansible_ssh_private_key_file=~/.vagrant.d/insecure_private_key

Now, create a playbook named `provision.yml` inside a `playbooks` directory:

{lang="text"}
    ---
    - hosts: gluster
      become: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.glusterfs
    
      tasks:
        - name: Ensure Gluster brick and mount directories exist.
          file: "path={{ item }} state=directory mode=0775"
          with_items:
            - "{{ gluster_brick_dir }}"
            - "{{ gluster_mount_dir }}"
    
        - name: Configure Gluster volume.
          gluster_volume:
            state: present
            name: "{{ gluster_brick_name }}"
            brick: "{{ gluster_brick_dir }}"
            replicas: 2
            cluster: "{{ groups.gluster | join(',') }}"
            host: "{{ inventory_hostname }}"
            force: yes
          run_once: true
    
        - name: Ensure Gluster volume is mounted.
          mount:
            name: "{{ gluster_mount_dir }}"
            src: "{{ inventory_hostname }}:/{{ gluster_brick_name }}"
            fstype: glusterfs
            opts: "defaults,_netdev"
            state: mounted

This playbook uses two roles to set up a firewall and install the required packages for GlusterFS to work. You can manually install both of the required roles with the command `ansible-galaxy install geerlingguy.firewall geerlingguy.glusterfs`, or add them to a `requirements.yml` file and install with `ansible-galaxy install -r requirements.yml`.

Gluster requires a 'brick' directory to use as a virtual filesystem, and our servers also need a directory where the filesystem can be mounted, so the first `file` task ensures both directories exist (`gluster_brick_dir` and `gluster_mount_dir`). Since we need to use these directory paths more than once, we use variables which will be defined later, in `vars.yml`.

Ansible's `gluster_volume` module (added in Ansible 1.9) does all the hard work of probing peer servers, setting up the brick as a Gluster filesystem, and configuring the brick for replication. Some of the most important configuration parameters for the `gluster_volume` module include:

  - `state`: Setting this to `present` makes sure the brick is present. It will also start the volume when it is first created by default, though this behavior can be overridden by the `start_on_create` option.
  - `name` and `brick` give the Gluster brick a name and location on the server, respectively. In this example, the brick will be located on the boot volume, so we also have to add `force: yes`, or Gluster will complain about not having the brick on a separate volume.
  - `replicas` tells Gluster how many replicas to ensure exist; this number can vary depending on how many servers you have in the brick's `cluster`, and how tolerance you have for server outages. We won't get much into tuning GlusterFS for performance and resiliency, but most situations warrant a value of `2` or `3`.
  - `cluster` defines all the hosts which will contain the distributed filesystem. In this case, all the `gluster` servers in our Ansible inventory should be included, so we use a Jinja2 `join` filter to join all the addresses into a list.
  - `host` sets the host for peer probing explicitly. If you don't set this, you can sometimes get errors on brick creation, depending on your network configuration.

We only need to run the `gluster_volume` module once for all the servers, so we add `run_once: true`.

The last task in the playbook uses Ansible's `mount` module to ensure the Gluster volume is mounted on each of the servers, in the `gluster_mount_dir`.

After the playbook is created, we need to define all the variables used in the playbook. Create a `vars.yml` file inside the `playbooks` directory, with the following variables:

{lang="text"}
    ---
    # Firewall configuration.
    firewall_allowed_tcp_ports:
      - 22
      # For Gluster.
      - 111
      # Port-mapper for Gluster 3.4+.
      # - 2049
      # Gluster Daemon.
      - 24007
      # 24009+ for Gluster <= 3.3; 49152+ for Gluster 3.4+.
      - 24009
      - 24010
      # Gluster inline NFS server.
      - 38465
      - 38466
    firewall_allowed_udp_ports:
      - 111
    
    # Gluster configuration.
    gluster_mount_dir: /mnt/gluster
    gluster_brick_dir: /srv/gluster/brick
    gluster_brick_name: gluster

This variables file should be pretty self-explanatory; all the ports required for Gluster are opened in the firewall, and the three Gluster-related variables we use in the playbook are defined.

Now that we have everything set up, the folder structure should look like this:

{lang="text",linenos=off}
    gluster/
      playbooks/
        provision.yml
        main.yml
      inventory
      Vagrantfile

Change directory into the `gluster` directory, and run `vagrant up`. After a few minutes, provisioning should have completed successfully. To ensure Gluster is working properly, you can run the following two commands, which should give information about Gluster's peer connections and the configured `gluster` volume:

{lang="text",linenos=off}
    $ ansible gluster -i inventory -a "gluster peer status" -s
    192.168.29.2 | success | rc=0 >>
    Number of Peers: 1
    
    Hostname: 192.168.29.3
    Port: 24007
    Uuid: 1340bcf1-1ae6-4e55-9716-2642268792a4
    State: Peer in Cluster (Connected)
    
    192.168.29.3 | success | rc=0 >>
    Number of Peers: 1
    
    Hostname: 192.168.29.2
    Port: 24007
    Uuid: 63d4a5c8-6b27-4747-8cc1-16af466e4e10
    State: Peer in Cluster (Connected)

{lang="text",linenos=off}
    $ ansible gluster -i inventory -a "gluster volume info" -s
    192.168.29.3 | success | rc=0 >>
    
    Volume Name: gluster
    Type: Replicate
    Volume ID: b75e9e45-d39b-478b-a642-ccd16b7d89d8
    Status: Started
    Number of Bricks: 1 x 2 = 2
    Transport-type: tcp
    Bricks:
    Brick1: 192.168.29.2:/srv/gluster/brick
    Brick2: 192.168.29.3:/srv/gluster/brick
    
    192.168.29.2 | success | rc=0 >>
    
    Volume Name: gluster
    Type: Replicate
    Volume ID: b75e9e45-d39b-478b-a642-ccd16b7d89d8
    Status: Started
    Number of Bricks: 1 x 2 = 2
    Transport-type: tcp
    Bricks:
    Brick1: 192.168.29.2:/srv/gluster/brick
    Brick2: 192.168.29.3:/srv/gluster/brick

You can also do the following to confirm that files are being replicated/distributed correctly:

  1. Log into the first server: `vagrant ssh gluster1`
  2. Create a file in the mounted gluster volume: `sudo touch /mnt/gluster/test`
  3. Log out of the first server: `exit`
  4. Log into the second server: `vagrant ssh gluster2`
  5. List the contents of the gluster directory: `ls /mnt/gluster`

You should see the `test` file you created in step 2; this means Gluster is working correctly!

### Summary

Deploying distributed file systems like Gluster can seem challenging, but Ansible simplifies the process, and more importantly, does so idempotently; each time you run the playbook again, it will ensure everything stays configured as you've set it.

This example Gluster configuration can be found in its entirety on GitHub, in the [Gluster example](https://github.com/geerlingguy/ansible-vagrant-examples/tree/master/gluster) in the Ansible Vagrant Examples project.

## Mac Provisioning with Ansible and Homebrew

The next example will be specific to the Mac, but the principle behind it applies universally. How many times have you wanted to hit the 'reset' button on your day-to-day workstation or personal computer? How much time to you spend automating configuration and testing of applications and infrastructure at your day job, and how little do you spend automating your *own* local environment?

Over the past few years, as I've gone through four Macs (one personal, three employer-provided), I decided to start fresh on each new Mac (rather than transfer all my cruft from my old Mac to my new Mac through Apple's Migration Assistant). I had a problem, though; I had to spend at least 4-6 hours on each Mac, downloading, installing, and configuring everything. And I had another problem---since I actively used at least two separate Macs, I had to manually install and configure new software on both Macs whenever I wanted to try a new tool.

To restore order to this madness, I wrapped up all the configuration I could into a set of [dotfiles](https://github.com/geerlingguy/dotfiles) and used git to synchronize the dotfiles to all my workstations.

However, even with the assistance of [Homebrew](http://brew.sh/), an excellent package manager for OS X, there was still a lot of manual labor involved in installing and configuring my favorite apps and command line tools.

### Running Ansible playbooks locally

We saw examples of running playbooks with `connection: local` earlier while provisioning virtual machines in the cloud through our local workstation. But in fact, you can perform _any_ Ansible task using a local connection. This is how we will configure our local workstation, using Ansible.

I usually begin building a playbook by adding the basic scaffolding first, then filling in details as I go. You can follow along by creating the playbook `main.yml` with:

{lang="text"}
    ---
    - hosts: localhost
      user: jgeerling
      connection: local
    
      vars_files:
        - vars/main.yml
    
      roles: []
    
      tasks: []

We'll store any variables we need in the included `vars/main.yml` file. The `user` is set to my local user account (in this case, `jgeerling`), so file permissions are set for my account, and tasks are run under my own account in order to minimize surprises.

T> If certain tasks need to be run with sudo privileges, you can add `become: yes` to the task, and either run the playbook with `--ask-sudo-pass` (in which case, Ansible will prompt you for your sudo password before running the playbook) or run the playbook normally, and wait for Ansible to prompt you for your sudo password.

### Automating Homebrew package and app management

Since I use Homebrew (billed as "the missing package manager for OS X") for most of my application installation and configuration, I created the role `geerlingguy.homebrew`, which first installs Homebrew and then installs all the applications and packages I configure in a few simple variables.

The next step, then, is to add the Homebrew role and configure the required variables. Inside `main.yml`, update the `roles` section:

{lang="text",starting-line-number=9}
      roles:
        - geerlingguy.homebrew

Then add the following into `vars/main.yml`:

{lang="text"}
    ---
    homebrew_installed_packages:
      - ansible
      - sqlite
      - mysql
      - php56
      - python
      - ssh-copy-id
      - cowsay
      - pv
      - drush
      - wget
      - brew-cask
    
    homebrew_taps:
      - caskroom/cask
      - homebrew/binary
      - homebrew/dupes
      - homebrew/php
      - homebrew/versions
    
    homebrew_cask_appdir: /Applications
    homebrew_cask_apps:
      - google-chrome
      - firefox
      - sequel-pro
      - sublime-text
      - vagrant
      - vagrant-manager
      - virtualbox

Homebrew has a few tricks up its sleeve, like being able to manage general packages like PHP, MySQL, Python, Pipe Viewer, etc. natively (using commands like `brew install [package]` and `brew uninstall package`), and can also install and manage general application installation for many Mac apps, like Chrome, Firefox, VLC, etc. using `brew cask`.

To anyone who's set up a new Mac the old-fashioned way---download 15 .dmg files, mount them, drag the applications to the Applications folder, eject them, delete the .dmg files---Homebrew's simplicity and speed are a true godsend. This Ansible playbook has so far automated that process completely, so you don't even have to run the Homebrew commands manually! The `geerlingguy.homebrew` role uses Ansible's built-in `homebrew` module to manage package installation, along with some custom tasks to manage cask applications.

### Configuring Mac OS X through dotfiles

Just like there's a `homebrew` role on Ansible Galaxy, made for configuring and installing packages via Homebrew, there's a `dotfiles` role you can use to download and configure your local dotfiles.

I> Dotfiles are named as such because they are files in your home directory that begin with a `.`. Many programs and shell environments read local configuration from dotfiles, so dotfiles are a simple, efficient, and easily-synchronized method of customizing your development environment for maximum efficiency.

In this example, we'll use the author's dotfiles, but you can tell the role to use whatever set of dotfiles you want.

Add another role to the `roles` list:

{lang="text",starting-line-number=9}
      roles:
        - geerlingguy.homebrew
        - geerlingguy.dotfiles

Then, add the following three variables to your `vars/main.yml` file:

{lang="text",starting-line-number=2}
    dotfiles_repo: https://github.com/geerlingguy/dotfiles.git
    dotfiles_repo_local_destination: ~/repositories/dotfiles
    dotfiles_files:
      - .bash_profile
      - .gitignore
      - .inputrc
      - .osx
      - .vimrc

The first variable gives the git repository URL for the dotfiles to be cloned. The second gives a local path for the repository to be stored, and the final variable tells the role which dotfiles it should use from the specified repository.

The `dotfiles` role clones the specified dotfiles repository locally, then symlinks every one of the dotfiles specified in `dotfiles_files` into your home folder (removing any existing dotfiles of the same name).

If you want to run the `.osx` dotfile, which adjusts many system and application settings, add in a new task under the `tasks` section in the main playbook:

      tasks:
        - name: Run .osx dotfiles.
          shell: ~/.osx --no-restart
          changed_when: false

In this case, the `.osx` dotfile allows a `--no-restart` flag to be passed to prevent the script from restarting certain apps and services including Terminal---which is good, since you'd likely be running the playbook from within Terminal.

At this point, you already have the majority of your local environment set up. Copying additional settings and tweaking things further is an exercise in adjusting your dotfiles or including another playbook that copies or links preference files into the right places.

I'm constantly tweaking my own development workstation, and for the most part, all my configuration is wrapped up in my [Mac Development Ansible Playbook](https://github.com/geerlingguy/mac-dev-playbook), available on GitHub. I'd encourage you to fork that project, as well as my dotfiles, if you'd like to get started automating the build of your own development workstation. Even if you don't use a Mac, most of the structure is similar; just substitute a different package manager, and start automating!

### Summary

Ansible is the best way to automate infrastructure provisioning and configuration. Ansible can also be used to configure your own workstation, saving you the time and frustration it takes to do so yourself. Unfortunately, you can't yet provision yourself a new top-of-the-line workstation with Ansible!

You can find the full playbook I'm currently using to configure my Macs on GitHub: [Mac Development Ansible Playbook](https://github.com/geerlingguy/mac-dev-playbook).

## Docker-based Infrastructure with Ansible

Docker is a highly optimized platform for building and running containers on local machines and servers in a highly efficient manner. You can think of Docker containers as sort-of lightweight virtual machines. This book won't go into the details of how Docker and Linux containers work, but will provide an introduction to how Ansible can integrate with Docker to build, manage, and deploy containers.

I> Prior to running example Docker commands or building and managing containers using Ansible, you'll need to make sure Docker is installed either on your workstation or a VM or server where you'll be testing everything. Please see the [installation guide for Docker](https://docs.docker.com/installation/) for help installing Docker on whatever platform you're using.

### A brief introduction to Docker containers

Starting with an extremely simple example, let's build a Docker image from a Dockerfile. In this case, we want to show how Dockerfiles work and how we can use Ansible to build the image in the same way as if we were to use the command line with `docker build`.

Let's start with a really simple Dockerfile:

{lang="text"}
    # Build an example Docker container image.
    FROM busybox
    MAINTAINER Jeff Geerling <geerlingguy@mac.com>
    
    # Run a command when the container starts.
    CMD ["/bin/true"]

This Docker container doesn't do much, but that's okay; we just want to build it and verify that it's present and working---first with Docker, then with Ansible.

Save the above file as `Dockerfile` inside a new directory, and then on the command line, run the following command to build the container:

{lang="text",linenos=off}
    $ docker build -t test .

After a few seconds, the Docker image should be built, and if you list all local images with `docker image`, you should see your new test image (along with the busybox image, which was used as a base):

{lang="text",linenos=off}
    $ docker images
    REPOSITORY  TAG     IMAGE ID      CREATED             VIRTUAL SIZE
    test        latest  50d6e6479bc7  About a minute ago  2.433 MB
    busybox     latest  4986bf8c1536  2 weeks ago         2.433 MB

If you want to run the container image you just created, enter the following:

{lang="text",linenos=off}
    $ docker run --name=test test

This creates a Docker container with the name `test`, and starts the container. Since the only thing our container does is calls `/bin/true`, the container will run the command, then exit. You can see the current status of all your containers (whether or not they're actively running) with the `docker ps -a` command:

{lang="text",linenos=off}
    $ docker ps -a
    CONTAINER ID  IMAGE        [...]  CREATED        STATUS
    bae0972c26d4  test:latest  [...]  3 seconds ago  Exited (0) 2s ago

You can control the container using either the container ID (in this case, `bae0972c26d4`) or the name (`test`); start with `docker start [container]`, stop with `docker stop [container]`, delete/remove with `docker rm [container]`.

If you delete the container (`docker rm test`) and the image you built (`docker rmi test`), you can experiment with the Dockerfile by changing it and rebuilding the image with `docker build`, then running the resulting image with `docker run`. For example, if you change the command from `/bin/true` to `/bin/false`, then run build and run the container, `docker ps -a` will show that the container exited with the status code `1` instead of `0`.

For our purposes, this is a simple enough introduction to how Docker works. To summarize:

  - Dockerfiles contain the instructions Docker uses to build containers.
  - `docker build` builds Dockerfiles and generates container images.
  - `docker images` lists all images present on the system.
  - `docker run` runs created images.
  - `docker ps -a` lists all containers, both running and stopped.

When developing Dockerfiles to containerize your own applications, you will likely want to get familiar with the Docker CLI and how the process works from a manual perspective. But when building the final images and running them on your servers, Ansible can help ease the process.

### Using Ansible to build and manage containers

Ansible has a built-in [Docker module](http://docs.ansible.com/docker_module.html) that integrates nicely with Docker for container management. We're going to use it to automate the building and running of the container (managed by the Dockerfile) we just created.

Move the Dockerfile you had into a subdirectory, and create a new Ansible playbook (call it `main.yml`) in the project root directory. The directory layout should look like:

{lang="text",linenos=off}
    docker/
      main.yml
      test/
        Dockerfile

Inside the new playbook, add the following:

{lang="text"}
    ---
    - hosts: localhost
      connection: local

      tasks:
        - name: Build Docker image from Dockerfiles.
          docker_image:
            name: test
            path: test
            state: build

The playbook uses the `docker_image` module to build an image. Provide a name for the image, the path to the Dockerfile (in this case, inside the `test` directory), and tell Ansible via the `state` parameter whether the image should be `present`, `absent`, or built (via `build`).

I> Ansible's Docker integration may require you to install an extra Docker python library on the system running the Ansible playbook. For example, on ArchLinux, if you get the error "failed to import Python module", you will need to install the `python2-docker-py` package.

W> The `docker_image` module is listed as being deprecated as of early 2015. The module's functionality will soon be moved into the main `docker` module, but until that time, this playbook should work as-is.

Run the playbook (`$ ansible-playbook main.yml`), and then list all the Docker images (`$ docker images`). If all was successful, you should see a fresh `test` image in the list.

Run `docker ps -a` again, though, and you'll see that the new `test` image was never run and is absent from the output. Let's remedy that by adding another task to our Ansible playbook:

{lang="text",starting-line-number=12}
    - name: Run the test container.
      docker:
        image: test:latest
        name: test
        state: running

If you run the playbook again, Ansible will run the Docker container. Check the list of containers with `docker ps -a`, and you'll note that the `test` container is again present.

You can remove the container and the image via ansible by changing the `state` parameter to `absent` for both tasks.

T> This playbook assumes you have both Docker and Ansible installed on whatever host you're using to test Docker containers. If this is not the case, you may need to modify the example so the Ansible playbook is targeting the correct `hosts` and using the right connection settings. Additionally, if the user account under which you run the playbook can't run `docker` commands, you may need to use `become` with this playbook.

I> The code example above can be found in the [Ansible for DevOps GitHub repository](https://github.com/geerlingguy/ansible-for-devops/tree/master/docker).

### Building a Flask app with Ansible and Docker

Let's build a more useful Docker-powered environment, with a container that runs our application (built with Flask, a lightweight Python web framework), and a container that runs a database (MySQL), along with a data container. We need a separate data container to persist the MySQL database, because data changed inside the MySQL container is lost every time the container stops.

{width=60%}
![Docker stack for Flask App](images/8-flask-docker-stack.png)

We'll create a VM using Vagrant to run our Docker containers so the same Docker configuration can be tested on on any machine capable of running Ansible and Vagrant. Create a `docker` folder, and inside it, the following `Vagrantfile`:

{lang=ruby}
    # -*- mode: ruby -*-
    # vi: set ft=ruby :
    
    VAGRANTFILE_API_VERSION = "2"
    
    Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
      config.vm.box = "geerlingguy/ubuntu1404"
      config.vm.network :private_network, ip: "192.168.33.39"
      config.ssh.insert_key = false
    
      config.vm.provider :virtualbox do |v|
        v.customize ["modifyvm", :id, "--name", "docker.dev"]
        v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        v.customize ["modifyvm", :id, "--memory", 1024]
        v.customize ["modifyvm", :id, "--cpus", 2]
        v.customize ["modifyvm", :id, "--ioapic", "on"]
      end
    
      # Enable provisioning with Ansible.
      config.vm.provision "ansible" do |ansible|
        ansible.playbook = "provisioning/main.yml"
      end
    
    end

We'll use Ubuntu 14.04 for this example, and we've specified an Ansible playbook (`provisioning/main.yml`) to set everything up. Inside `provisioning/main.yml`, we need to first install and configure Docker (which we'll do using the Ansible Galaxy role `angstwad.docker_ubuntu`), then run some additional setup tasks, and finally build and start the required Docker containers:

{lang="text"}
    ---
    - hosts: all
      become: yes
    
      roles:
        - role: angstwad.docker_ubuntu
    
      tasks:
        - include: setup.yml
        - include: docker.yml

We're using `sudo` for everything because Docker either requires root privileges, or requires the current user account to be in the `docker` group. It's simplest for our purposes to set everything up with `sudo` by setting `become: yes`.

Angstwad's `docker_ubuntu` role requires no additional settings or configuration, so we can move on to `setup.yml` (in the same `provisioning` directory alongside `main.yml`):

{lang="text"}
    ---
    - name: Install Pip.
      apt: name=python-pip state=present
      become: yes
    
    - name: Install Docker Python library.
      pip: name=docker-py state=present
      become: yes

Ansible needs the `docker-py` library in order to control Docker via Python, so we install `pip`, then use it to install `docker-py`.

Next is the meat of the playbook: `docker.yml` (also in the `provisioning` directory). The first task is to build Docker images for our data, application, and database containers:

{lang="text"}
    ---
    - name: Build Docker images from Dockerfiles.
      docker_image:
        name: "{{ item.name }}"
        tag: "{{ item.tag }}"
        path: "/vagrant/provisioning/{{ item.directory }}"
        state: build
      with_items:
        - { name: data, tag: "data", directory: data }
        - { name: www, tag: "flask", directory: www }
        - { name: db, tag: mysql, directory: db }

Don't worry that we haven't yet created the actual Dockerfiles required to create the Docker images; we'll do that after we finish structuring everything with Ansible.

Like our earlier usage of `docker_image`, we supply a `name`, `path`, and `state` for each image. In this example, we're also adding a `tag`, which behaves like a git tag, allowing future Docker commands to use the images we created at a specific version. We'll be building three containers, `data`, `www`, and `db`, and we're pointing Docker to the path `/vagrant/provisioning/[directory]`, where `[directory]` contains the Dockerfile and any other helpful files to be used to build the Docker image.

After building the images, we will need to start each of them (or at least make sure a container is *present*, in the case of the `data` container---since you can use data volumes from non-running containers). We'll do that in three separate `docker` tasks:

{lang="text",starting-line-number=13}
    # Data containers don't need to be running to be utilized.
    - name: Run a Data container.
      docker:
        image: data:data
        name: data
        state: present
    
    - name: Run a Flask container.
      docker:
        image: www:flask
        name: www
        state: running
        command: python /opt/www/index.py
        ports: "80:80"
    
    - name: Run a MySQL container.
      docker:
        image: db:mysql
        name: db
        state: running
        volumes_from: data
        command: /opt/start-mysql.sh
        ports: "3306:3306"

Each of these containers' configuration is a little more involved than the previous. In the case of the first container, it's just `present`; Ansible will ensure a `data` container is present.

For the Flask container, we need to make sure our app is not only running, but *continues* to run. So, unlike our earlier usage of `/bin/true` to run a container briefly and exit, in this case we will provide an explicit command to run:

{lang="text",starting-line-number=26}
        command: python /opt/www/index.py

Calling the script directly will launch the app in the foreground and log everything to stdout, making it easy to inspect what's going on with `docker logs [container]` if needed.

Additionally, we want to map the container's port 80 to the host's port 80, so external users can load pages over HTTP. This is done using the `ports` option, passing data just as you would using Docker's `--publish` syntax.

The Flask container will have a static web application running on it, and has no need for extra non-transient file storage, but the MySQL container will mount a data volume from the `data` container, so it has a place to store data that won't vanish when the container dies and is restarted.

Thus, for the `db` container, we have two special options: the `volumes_from` option, which mounts volumes from the specified container (in this case, the `data` container), and the `command`, which calls a shell script to start MySQL. We'll get to why we're running a shell script and not launching a MySQL daemon directly in a bit.

Now that we have the playbook structured to build our simple Docker-based infrastructure, we'll build out each of the three Dockerfiles and related configuration to support the `data`, `www`, and `db` containers.

At this point, we should have a directory structure like:

{lang="text",linenos=off}
    docker/
      provisioning/
        data/
        db/
        www/
        docker.yml
        main.yml
        setup.yml
      Vagrantfile

W> It's best to use lightweight base images without any extra frills instead of heavyweight 'VM-like' images. Additionally, lightweight server environments where containers are built and run, like CoreOS, don't need the baggage of a standard Linux distribution. If you need Ansible available for configuration and container management in such an environment, you also need to have Python and other dependencies installed. Check out these two resources in particular for tips and tricks with managing and configuring containers with Ansible on CoreOS servers: [Managing CoreOS with Ansible](https://coreos.com/blog/managing-coreos-with-ansible/) and [Provisioning CoreOS with Ansible](http://www.tazj.in/en/1410951452).

#### Data storage container

For the data storage container, we don't need much; we just need to create a directory and set it as an exposed mount point using `VOLUME`:

{lang="text"}
    # Build a simple MySQL data volume Docker container.
    FROM busybox
    MAINTAINER Jeff Geerling <geerlingguy@mac.com>
    
    # Create data volume for MySQL.
    RUN mkdir -p /var/lib/mysql
    VOLUME /var/lib/mysql

We create a directory (line 6), and expose the directory as a volume (line 7) which can be mounted by the host or other containers. Save the above into a new file, `docker/provisioning/data/Dockerfile`.

T> This container builds on top of the official `busybox` base image. Busybox is an extremely simple distribution that is Linux-like but does not contain every option or application generally found in popular distributions like Debian, Ubuntu, or RHEL. Since we only need to create and share a directory, we don't need any additional 'baggage' inside the container. In the Docker world, it's best to use the most minimal base images possible, and to only install and run the bare necessities inside each container to support the container's app.

#### Flask container

[Flask](http://flask.pocoo.org/) is a lightweight Python web framework "based on Werkzeug, Jinja 2 and good intentions". It's a great web framework for small, fast, and robust websites and apps, or even a simple API. For our purposes, we need to build a Flask app that connects to a MySQL database and displays the status of the connection on a simple web page (very much like our PHP example, in the earlier Highly-Available Infrastructure example).

Here's the code for the Flask app (save it as `docker/provisioning/www/index.py.j2`):

{lang=python}
    # Infrastructure test page.
    from flask import Flask
    from flask import Markup
    from flask import render_template
    from flask.ext.sqlalchemy import SQLAlchemy
    
    app = Flask(__name__)
    
    # Configure MySQL connection.
    db = SQLAlchemy()
    db_uri = 'mysql://admin:admin@{{ host_ip_address }}/\
    information_schema'
    app.config['SQLALCHEMY_DATABASE_URI'] = db_uri
    db.init_app(app)
    
    @app.route("/")
    def test():
        mysql_result = False
        try:
            if db.session.query("1").from_statement("SELECT 1").all():
                mysql_result = True
        except:
            pass
    
        if mysql_result:
            result = Markup('<span style="color: green;">PASS</span>')
        else:
            result = Markup('<span style="color: red;">FAIL</span>')
    
        # Return the page with the result.
        return render_template('index.html', result=result)
    
    if __name__ == "__main__":
        app.run(host="0.0.0.0", port=80)

This simple app defines one route (`/`), listens on every interface on port 80, and shows a MySQL connection status page rendered by the template `index.html`. There's nothing particularly complicated in this application, but there is one Jinja2 varible (`{{ host_ip_address }}`) which an Ansible playbook will replace during deployment, and the app has a few dependencies (like `flask-sqlalchemy`) which will need to be installed via the Dockerfile.

Since we are using a Jinja2 template to render the page, let's create that template in `docker/provisioning/www/templates/index.html` (Flask automatically picks up any templates inside a `templates` directory):

{lang=html}
    <!DOCTYPE html>
    <html>
    <head>
      <title>Flask + MySQL Docker Example</title>
      <style>* { font-family: Helvetica, Arial, sans-serif }</style>
    </head>
    <body>
      <h1>Flask + MySQL Docker Example</h1>
      <p>MySQL Connection: {{ result }}</p>
    </body>
    </html>

In this case, the `.html` template contains a Jinja2 variable (`{{ result }}`), and Flask will fill in that variable with the status of the MySQL connection.

Now that we have the app defined, we need to build the container to run the app. Here is a Dockerfile that will install all the required dependencies, then copy a simple Ansible playbook and the app itself into place so we can do the more complicated configuration (like copying a template with variable replacement) through Ansible:

{lang="text"}
    # A simple Flask app container.
    FROM ansible/ubuntu14.04-ansible
    MAINTAINER Jeff Geerling <geerlingguy@mac.com>
    
    # Install Flask app dependencies.
    RUN apt-get install -y libmysqlclient-dev python-dev
    RUN pip install flask flask-sqlalchemy mysql-python
    
    # Install playbook and run it.
    COPY playbook.yml /etc/ansible/playbook.yml
    COPY index.py.j2 /etc/ansible/index.py.j2
    COPY templates /etc/ansible/templates
    RUN mkdir -m 755 /opt/www
    RUN ansible-playbook /etc/ansible/playbook.yml --connection=local
    
    EXPOSE 80

Instead of installing apt and pip packages using Ansible, we'll install them using `RUN` commands in the Dockerfile. This allows those commands to be cached by Docker. Generally, more complicated package installation and configuration is easier and more maintainable inside Ansible, but in the case of simple package installation, having Docker cache the steps so future `docker build` commands take seconds instead of minutes is worth the verbosity of the Dockerfile.

At the end of the Dockerfile, we run a playbook (which should be located in the same directory as the Dockerfile) and expose port 80 so the app can be accessed via HTTP by the outside world. Next we'll create the app deployment playbook.

W> Purists might cringe at the sight of an Ansible playbook inside a Dockerfile, and for good reason! Commands like the `ansible-playbook` command cover up configuration that might normally be done (and cached) within Docker. Additionally, using the `ansible/ubuntu14.04-ansible` base image (which includes Ansible) requires an initial download that's 50+ MB larger than a comparable debian or ubuntu image without Ansible. However, for brevity and ease of maintenance, we're using Ansible to manage all the app configuration inside the container (otherwise we'd need to run a bunch of verbose and incomprehensible shell commands to replace Ansible's `template` functionality).

In order for the Flask app to function properly, we need to get the `host_ip_address`, then replace the variable in the `index.py.j2` template. Create the Flask deployment playbook at `docker/provisioning/www/playbook.yml`:

{lang="text"}
    ---
    - hosts: localhost
      become: yes
    
      tasks:
        - name: Get host IP address.
          shell: "/sbin/ip route|awk '/default/ { print $3 }'"
          register: host_ip
          changed_when: false
    
        - name: Set host_ip_address variable.
          set_fact:
            host_ip_address: "{{ host_ip.stdout }}"
    
        - name: Copy Flask app into place.
          template:
            src: /etc/ansible/index.py.j2
            dest: /opt/www/index.py
            mode: 0755
    
        - name: Copy Flask templates into place.
          copy:
            src: /etc/ansible/templates
            dest: /opt/www
            mode: 0755

The shell command that registers the `host_ip` is a simple way to retrieve the IP while still letting Docker do it's own virtual network management.

The last two tasks copy the flask app and templates directory into place.

The `docker/provisioning/www` directory should now contain the following:

{lang="text",linenos=off}
    www/
      templates/
        index.html
      Dockerfile
      index.py.j2
      playbook.yml

#### MySQL container

We've configured MySQL a few times throughout this book, so little time will be spent discussing how MySQL is set up. We'll instead dive into how MySQL is configured to work inside a Docker container, with a persistent data volume from the previously-configured `data` container.

First, we'll create a really simple Ansible playbook to install and configure MySQL using the `geerlingguy.mysql` role:

{lang="text"}
    ---
    - hosts: localhost
      become: yes
    
      vars:
        mysql_users:
          - name: admin
            host: "%"
            password: admin
            priv: "*.*:ALL"
    
      roles:
        - geerlingguy.mysql

This playbook sets up one MySQL user using the `mysql_users` variable and runs the `geerlingguy.mysql` role. Save it as `docker/provisioning/db/playbook.yml`.

Next, we need to account for the fact that there are two conditions under which MySQL will be started:

  1. When Docker builds the container initially (using `docker build` through Ansible's `docker_image` module).
  2. When we launch the container and pass in the `data` volume (using `docker run` through Ansible's `docker` module).

In the latter case, the data volume's `/var/lib/mysql` directory will supplant the container's own directory, but it will be empty! Therefore, instead of just launching the MySQL daemon like we launched the Flask app in the `www` container, we need to build a small shell script that will run on container start to detect whether MySQL has already been setup inside `/var/lib/mysql`, and if it hasn't, to reconfigure MySQL so the data is there.

Here's a simple script to do just that, using the playbook we just created to do most of the heavy lifting. Save this as `docker/provisioning/db/start-mysql.sh`:

{lang=bash}
    #!/bin/bash
    
    # If connecting to a new data volume, we need to reconfigure MySQL.
    if [[ ! -d /var/lib/mysql/mysql ]]; then
        rm -f ~/.my.cnf
        mysql_install_db
        ansible-playbook /etc/ansible/playbook.yml --connection=local
        mysqladmin shutdown
    fi
    
    exec /usr/bin/mysqld_safe

This bash script checks if there's already a `mysql` directory inside MySQL's default data directory, and if not (as is the case when we run the container with the `data` volume), it will remove any existing `.my.cnf` connection file, run `mysql_install_db` to initialize MySQL, then run the playbook, and shut down MySQL.

Once that's all done (or if the persistent `data` volume has already been set up previously), MySQL is started with the `mysqld_safe` startup script which, [according to the MySQL documentation](http://dev.mysql.com/doc/refman/5.6/en/mysqld-safe.html), is "the recommended way to start a mysqld server on Unix".

Next comes the Dockerfile, where we'll make sure the `playbook.yml` playbook and `start-mysql.sh` script are put in the right places, and expose the MySQL port so other containers can connect to MySQL.

{lang="text"}
    # A simple MySQL container.
    FROM ansible/ubuntu14.04-ansible
    MAINTAINER Jeff Geerling <geerlingguy@mac.com>
    
    # Install required Ansible roles.
    RUN ansible-galaxy install geerlingguy.mysql
    
    # Copy startup script.
    COPY start-mysql.sh /opt/start-mysql.sh
    RUN chmod +x /opt/start-mysql.sh
    
    # Install playbook and run it.
    COPY playbook.yml /etc/ansible/playbook.yml
    RUN ansible-playbook /etc/ansible/playbook.yml --connection=local
    
    EXPOSE 3306

Just as with the Flask app container, we're using a base image with Ubuntu 14.04 and Ansible. This time, since we're doing a bit more configuration via the playbook, we also need to install the `geerlingguy.mysql` role via Ansible Galaxy.

The `start-mysql.sh` script needs to be located in the `docker.yml` file we set up much earlier, where we're calling it with `command: /opt/start-mysql.sh`, so we copy it in place, then give `+x` permissions so Docker can execute the file.

Finally, the Ansible playbook that configures MySQL is copied into place, then run, and port 3306 is exposed.

The `docker/provisioning/db` directory should now contain the following:

{lang="text",linenos=off}
    db/
      Dockerfile
      playbook.yml
      start-mysql.sh

### Ship it!

Now that everything's in place, you should be able to cd into the main `docker` directory, and run `vagrant up`. After 10 minutes or so, Vagrant should show that Ansible provisioning was successful, and if you visit `http://192.168.33.39/` in your browser, you should see something like the following:

{width=80%}
![Docker orchestration success!](images/8-docker-success.png)

If you see "MySQL Connection: PASS", congratulations, everything worked! If it shows 'FAIL', you might need to give the MySQL a little extra time to finish it's reconfiguration, since it has to rebuild the database on first launch. If the page doesn't show up at all, you might want to compare your code with the [Docker LAMP example](https://github.com/geerlingguy/ansible-vagrant-examples/tree/master/docker) on GitHub.

### Summary

The entire [Docker LAMP example](https://github.com/geerlingguy/ansible-vagrant-examples/tree/master/docker) is available on GitHub, if you'd like to clone it and try it locally.

The Docker examples shown here barely scratch the surface of what makes Docker a fascinating and useful application deployment tool. Docker is still in its infancy, so there are dozens of ways to manage the building of Dockerfiles, the deployment of images, and the running and linking of containers. Ansible is a solid contender for managing Docker containers (_and_ the infrastruction on which they run), and can even be used within a Dockerfile to simplify complex container configurations.

{lang="text",linenos=off}
     _________________________________________
    / Any sufficiently advanced technology is \
    | indistinguishable from magic.           |
    \ (Arthur C. Clarke)                      /
     -----------------------------------------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||
