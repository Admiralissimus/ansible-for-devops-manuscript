# Chapter 8 - Ansible Cookbooks

Most of the book up to this point has demonstrated individual aspects of Ansible---inventory, playbooks, ad-hoc tasks, etc.---but this chapter will start to synthesize everything and show how Ansible is applied to real-world infrastructure management scenarios.

## Highly-Available Infrastructure with Ansible

Real-world web applications require redundancy and horizontal scalability with multi-server infrastructure. In the following example, we'll use Ansible to configure a complex infrastructure (illustrated below) on servers provisioned either locally via Vagrant and VirtualBox, or on a set of automatically-provisioned instances running on either DigitalOcean or Amazon Web Services:

{width=60%}
![Highly-Available Infrastructure.](images/8-highly-available-infrastructure.png)

**Varnish** acts as a load balancer and reverse proxy, fronting web requests and routing them to the application servers. We could just as easily use something like **Nginx** or **HAProxy**, or even a proprietary cloud-based solution like an Amazon **Elastic Load Balancer** or Linode **NodeBalancer**, but for simplicity's sake, and for flexibility in deployment, Varnish works well.

**Apache** and mod_php run a PHP-based application that tests the rest of the stack and displays the stack's current status.

A **Memcached** server provides a caching layer that can be used to store and retrieve frequently-accessed objects in lieu of slower database storage.

Two **MySQL** servers, configured as a master and slave, offer redundant and performant database access; all data will be replicated from the master to the slave, and the slave can also be used as a secondary server for read-only queries to take some load off the master.

### Directory Structure

In order to keep our configuration organized, we'll use the following structure for our playbooks and configuration:

{lang=text,linenos=off}
    lamp-infrastructure/
      inventories/
      playbooks/
        db/
        memcached/
        varnish/
        www/
      provisioners/
      configure.yml
      provision.yml
      requirements.txt
      Vagrantfile

Organizing things this way allows us to focus on each server configuration individually, then build playbooks for provisioning and configuring instances on different hosting providers later. This organization also enables you to use server playbooks independently, so you could, as an example, share the same `db` or `varnish` playbook directory for different applications and infrastructures.

### Individual Server Playbooks

Let's start building our individual server playbooks (in the `playbooks` directory). To make our playbooks more efficient, we'll use some contributed Ansible roles on Ansible Galaxy rather than install and configure everything step-by-step. We're going to target CentOS 6.x servers in these playbooks, but only minimal changes would be required to use the playbooks with Ubuntu or later versions of CentOS.

**Varnish**

Create a `main.yml` file within the the `playbooks/varnish` directory, with the following contents:

{lang=text}
    ---
    - hosts: lamp-varnish
      sudo: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.repo-epel
        - geerlingguy.varnish
    
      tasks:
        - name: Copy Varnish default.vcl.
          template:
            src: "templates/default.vcl.j2"
            dest: "/etc/varnish/default.vcl"
          notify: restart varnish

We're going to run this playbook on all hosts in the `lamp-varnish` inventory group (we'll create this later), and we'll run a few simple roles to configure the server:

  - `geerlingguy.firewall` configures a simple iptables-based firewall using a couple variables defined in `vars.yml`.
  - `geerlingguy.repo-epel` adds the EPEL repository (a prerequisite for varnish on CentOS 6.x hosts).
  - `geerlingguy.varnish` installs and configures Varnish.

Finally, a task copies over a custom `default.vcl` that configures Varnish, telling it where to find our web servers and how to load balance requests between the servers.

Let's create the two files referenced in the above playbook. First, `vars.yml`, in the same directory as the `main.yml` file we just created:

{lang=text}
    ---
    firewall_allowed_tcp_ports:
      - "22"
      - "80"
    
    varnish_use_default_vcl: false

The first variable tells the `geerlingguy.firewall` role to open TCP ports 22 and 80 for incoming traffic. The second variable tells the `geerlingguy.varish` role that we will be supplying our own `default.vcl` file in lieu of the basic one provided by the role.

Create a `templates` directory inside the `playbooks/varnish` directory, and inside, create a `default.vcl.j2` file. This file will use Jinja2 syntax to build Varnish's final `default.vcl` file, thus the extra `j2` extension:

{lang=text}
    vcl 4.0;
    
    import directors;
    
    {% for host in groups['lamp-www'] %}
    backend www{{ loop.index }} {
      .host = "{{ host }}";
      .port = "80";
    }
    {% endfor %}
    
    sub vcl_init {
      new vdir = directors.random();
    {% for host in groups['lamp-www'] %}
      vdir.add_backend(www{{ loop.index }}, 1);
    {% endfor %}
    }
    
    sub vcl_recv {
      set req.backend_hint = vdir.backend();
    
      # For testing ONLY; we want to make sure load balancing is working correctly.
      return (pass);
    }

We won't study Varnish's VCL syntax in depth here, but we can at least walk through this demonstration `default.vcl` and see what's going on:

  1. (1-3) Indicate that we're using the 4.0 version of the VCL syntax and importing the `directors` varnish module (which is used for configuring load balancing).
  2. (5-10) Define each web server as a new backend; give a host and a port through which varnish can contact each host.
  3. (12-17) When varnish first loads the VCL configuration, this function is called and initializes any required varnish modules. In this case, we're configuring a load balancer `vdir`, and adding each of the `www[#]` backends we defined earlier as backends to which the load balancer will distribute requests. We're going to use a `random` director so we can easily demonstrate the infrastructure's successful build, but other load balancing strategies are also available.
  4. (19-24) Define what happens when a request is received; in this case, we want to simple route the request to our `vdir` backend, and indicate that Varnish should *not* cache the result.

According to #4, we're actually *bypassing Varnish's caching layer*, which would be rather silly to do in most production circumstances. If you just need a load balancer without any reverse proxy/caching capabilities, there are better options. However, we are doing this so we can more easily verify our infrastructure is working as it should. If we used Varnish's caching, Varnish would only ever hit one of our two web servers during normal testing.

In terms of our caching/load balancing layer, this should suffice. For a true production environment, you'd probably want to at least remove the final `return (pass)`, and likely customize the rest of the VCL according to your application's needs.

**Apache / PHP**

Create a `main.yml` file within the the `playbooks/www` directory, with the following contents:

{lang=text}
    ---
    - hosts: lamp-www
      sudo: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.repo-epel
        - geerlingguy.apache
        - geerlingguy.php
        - geerlingguy.php-mysql
        - geerlingguy.php-memcached
    
      tasks:
        - name: Remove the Apache test page.
          file:
            path: /var/www/html/index.html
            state: absent
        - name: Copy our fancy server-specific home page.
          template:
            src: templates/index.php.j2
            dest: /var/www/html/index.php

As with Varnish's configuration, we'll configure a firewall and add the EPEL repository (which helps with the installation of certain PHP packages), and we'll also add the following roles:

  - `geerlingguy.apache` installs and configures the latest available version of the Apache web server.
  - `geerlingguy.php` installs and configures PHP to run through Apache.
  - `geerlingguy.php-mysql` adds MySQL support to PHP.
  - `geerlingguy.php-memcached` adds Memcached support to PHP.

Two final tasks remove the default `index.html` home page included with Apache, then places our new PHP-powered home page in its place.

As in the Varnish example, create the two files referenced in the above playbook. First, `vars.yml`, in the same directory as the `main.yml` file we just created:

{lang=text}
    ---
    firewall_allowed_tcp_ports:
      - "22"
      - "80"

Create a `templates` directory inside the `playbooks/www` directory, and inside, create an `index.php.j2` file. This file will use Jinja2 syntax to build a (relatively) simple PHP script to check the health and status of all the servers in our infrastructure:

{lang=text}
    <?php
    /**
     * @file
     * Infrastructure test page.
     *
     * DO NOT use this in production. It is simply a PoC.
     */
    
    $mysql_servers = array(
    {% for host in groups['lamp-db'] %}
      '{{ host }}',
    {% endfor %}
    );
    $mysql_results = array();
    foreach ($mysql_servers as $host) {
      if ($result = mysql_test_connection($host)) {
        $mysql_results[$host] = '<span style="color: green;">PASS</span> (' . $result['status'] . ')';
      }
      else {
        $mysql_results[$host] = '<span style="color: red;">FAIL</span>';
      }
    }
    
    // Connect to Memcached.
    $memcached_result = '<span style="color: red;">FAIL</span>';
    if (class_exists('Memcached')) {
      $memcached = new Memcached;
      $memcached->addServer('{{ groups['lamp-memcached'][0] }}', 11211);

      // Test adding a value to memcached.
      if ($memcached->add('test', 'success', 1)) {
        $result = $memcached->get('test');
        if ($result == 'success') {
          $memcached_result = '<span style="color: green;">PASS</span>';
          $memcached->delete('test');
        }
      }
    }
    
    /**
     * Connect to a MySQL server and test the connection.
     *
     * @param string $host
     *   IP Address or hostname of the server.
     *
     * @return array
     *   Array with keys 'success' (bool) and 'status' ('slave' or 'master'). Empty
     *   if connection failure.
     */
    function mysql_test_connection($host) {
      $username = 'mycompany_user';
      $password = 'secret';
      try {
        $db = new PDO(
          'mysql:host=' . $host . ';dbname=mycompany_database',
          $username,
          $password,
          array(PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION));
    
        // Query to see if the server is configured as a master or slave.
        $statement = $db->prepare("SELECT variable_value FROM information_schema.global_variables WHERE variable_name = 'LOG_BIN';");
        $statement->execute();
        $result = $statement->fetch();

        return array(
          'success' => TRUE,
          'status' => ($result[0] == 'ON') ? 'master' : 'slave',
        );
      }
      catch (PDOException $e) {
        return array();
      }
    }
    ?>
    <!DOCTYPE html>
    <html>
    <head>
      <title>Host {{ inventory_hostname }}</title>
      <style>* { font-family: Helvetica, Arial, sans-serif }</style>
    </head>
    <body>
      <h1>Host {{ inventory_hostname }}</h1>
      <?php foreach ($mysql_results as $host => $result): ?>
        <p>MySQL Connection (<?php print $host; ?>): <?php print $result; ?></p>
      <?php endforeach; ?>
      <p>Memcached Connection: <?php print $memcached_result; ?></p>
    </body>
    </html>

T> Don't try transcribing this example manually; you can get the code from this book's repository on GitHub. Visit the [ansible-for-devops](https://github.com/geerlingguy/ansible-for-devops) repository and download the source for [index.php.j2](https://github.com/geerlingguy/ansible-for-devops/blob/master/lamp-infrastructure/playbooks/www/templates/index.php.j2)

As this is the heart of the example application we're deploying to the infrastructure, it's necessarily a bit more complex than most examples in the book, but a quick run through follows:

  - (9-22) Iterate through all the `lamp-db` MySQL hosts defined in the playbook inventory, and test the ability to connect to them, and whether they are configured as master or slave, using the `mysql_test_connection()` function defined later (40-73).
  - (24-38) Check the first defined `lamp-memcached` Memcached host defined in the playbook inventory, confirming the ability to connect and create, retrieve, and delete a value from the cache.
  - (75-88) Print the results of all the MySQL and Memcached tests, along with `{{ inventory_hostname }}` as the page title, so we can easily see which web server is serving the viewed page.

At this point, the heart of our infrastructure---the application that will test and display the status of all our servers---is ready to go.

**Memcached**

After the previous two playbooks, the Memcached server playbook will be much simpler for our purposes. Create `playbooks/memcached/main.yml` with the following contents:

{lang=text}
    ---
    - hosts: lamp-memcached
      sudo: yes
    
      vars_files:
        - vars.yml
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.memcached

As with the other servers, we need to ensure a couple TCP ports are open using the simple `geerlingguy.firewall` role. After that, we need to install Memcached, which is simply done using the `geerlingguy.memcached` role.

In our `vars.yml` file (in the same directory as the fresh `main.yml` file you just created), place the following:

{lang=text}
    ---
    firewall_allowed_tcp_ports:
      - "22"
    firewall_additional_rules:
      - "iptables -A INPUT -p tcp --dport 11211 -s {{ groups['lamp-www'][0] }} -j ACCEPT"
      - "iptables -A INPUT -p tcp --dport 11211 -s {{ groups['lamp-www'][1] }} -j ACCEPT"

We need port 22 open for remote access, but in Memcached's case, a simple way to restrict access is to add manual iptables rules to allow access on port 11211 for the web servers *only*. We're manually adding one rule per `lamp-www` server, using the generated `groups` variable that Ansible uses to track all inventory groups currently available.

W> The **principle of least privilege** "requires that in a particular abstraction layer of a computing environment, every module ... must be able to access only the information and resources that are necessary for its legitimate purpose" (Source: [Wikipedia](http://en.wikipedia.org/wiki/Principle_of_least_privilege)). Always restrict services and ports to only those servers or users that need access!

**MySQL**

Our MySQL configuration is necessarily the most complex of the bunch. In addition to the generic installation and configuration of MySQL, we will need to configure MySQL users per-host, and set up master-slave replication. Because we want to build a flexible playbook that can be used with a variety of provisioned infrastructures, we need to dynamically create some variables so they have the right server addresses.

Let's create `playbooks/db/main.yml`:

{lang=text}
    ---
    - hosts: lamp-db
      sudo: yes
    
      vars_files:
        - vars.yml
    
      pre_tasks:
        - name: Create dynamic MySQL variables.
          set_fact:
            mysql_users:
              - { name: mycompany_user, host: "{{ groups['lamp-www'][0] }}", password: secret, priv: "*.*:SELECT" }
              - { name: mycompany_user, host: "{{ groups['lamp-www'][1] }}", password: secret, priv: "*.*:SELECT" }
            mysql_replication_master: "{{ groups['a4d.lamp.db.1'][0] }}"
    
      roles:
        - geerlingguy.firewall
        - geerlingguy.mysql

Most of the playbook is straightforward, but in this instance, we're using `set_fact` as a `pre_task` (to be run before the `geerlingguy.firewall` and `geerlingguy.mysql` roles) so we can dynamically create some variables that will be used by MySQL.

`set_fact` allows us to wait until other Ansible plays have run (in this case, plays which may be provisioning individual servers and registering them in new inventory groups), then define a variable at runtime which will be available for all later tasks and plays.

Here we are creating two new variables:

  - `mysql_users` is a list of users the `geerlingguy.mysql` role will create when it runs. This variable will be used on all database servers so both of the two `lamp-www` servers get `SELECT` privileges on all databases.
  - `mysql_replication_master` is used to indicate to the `geerlingguy.mysql` role which database server is the master; it will perform certain steps differently depending on whether the server being configured is a master or slave, and ensure that all the slaves are configured to replicate data from the master.

We'll need a few other variables to configure MySQL successfully, but these variables need not be created at runtime, so we can define them inside `playbooks/db/vars.yml`:

{lang=text}
    ---
    firewall_allowed_tcp_ports:
      - "22"
      - "3306"
    
    mysql_replication_user: {name: 'replication', password: 'secret'}
    mysql_databases:
      - { name: mycompany_database, collation: utf8_general_ci, encoding: utf8 }

In this case, we're going to allow access to port 3306 to anyone, but according to the **principle of least privilege** discussed earlier, you would be justified in restricting this port to only the servers and users that need access to MySQL. In this case, the attack vector is mitigated by the fact that we rely on MySQL's own authentication layer in our dynamic `mysql_user` configuration inside `main.yml`.

We are defining two MySQL variables, one to set up a replication user for the replication between master and slaves (`mysql_replication_user`), and another to define a list of databases that will be created (if they don't already exist) on the database servers (`mysql_databases`).

With the configuration of the database servers complete, all of our server-specific playbooks are ready to go.

### Main Playbook for Configuring All Servers

To put all the server-specific playbooks together, we can define a simple playbook that includes each of the group-specific playbooks. Create a `configure.yml` file in the project's root directory, with the following contents:

{lang=text}
    ---
    - include: playbooks/varnish/main.yml
    - include: playbooks/www/main.yml
    - include: playbooks/db/main.yml
    - include: playbooks/memcached/main.yml

At this point, if you statically defined inventory groups like `lamp-www`, `lamp-db`, etc., and created the file above, you could run `ansible-playbook configure.yml` and you'd have a full HA infrastructure at the ready!

But we're going to continue building out this infrastructure to make it even more flexible and useful.

### Getting the required roles

Ansible allows you to define all the required Ansible Galaxy roles for a given project in a `requirements.txt` file. Instead of having to remember to run `ansible-galaxy install -y [role1] [role2] [role3]` for each of the roles we're using, we can create `requirements.txt` in the root of our project, with the following contents:

{lang=text}
    geerlingguy.firewall
    geerlingguy.repo-epel
    geerlingguy.varnish
    geerlingguy.apache
    geerlingguy.php
    geerlingguy.php-mysql
    geerlingguy.php-memcached
    geerlingguy.mysql
    geerlingguy.memcached

To make sure all the required dependencies are available, just run `ansible-galaxy install -r requirements.txt` from within the project's root.

### Vagrantfile for Local Infrastructure via VirtualBox

As with many other examples in this book, we're going to use Vagrant and VirtualBox to build the infrastructure locally. This lets us test things as much as we want with zero costs, and also results in often faster infrastructure testing (assuming you're using a moderately beefy computer), since everything is orchestrated over a local private network.

Our basic Vagrantfile layout will be something like the following:

  1. Define a base box (in this case, CentOS 6.x) and VM hardware defaults.
  2. Define all the VMs to be built, with VM-specific IP addresses and hostname configuration.
  3. Define the Ansible provisioner along with the last VM, so Ansible can run once at the end of Vagrant's build cycle.

Here's the Vagrantfile in all its glory:

{lang=ruby}
    # -*- mode: ruby -*-
    # vi: set ft=ruby :
    
    Vagrant.configure("2") do |config|
      # Base VM OS configuration.
      config.vm.box = "geerlingguy/centos6"
    
      # General VirtualBox VM configuration.
      config.vm.provider :virtualbox do |v|
        v.customize ["modifyvm", :id, "--memory", 512]
        v.customize ["modifyvm", :id, "--cpus", 1]
        v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        v.customize ["modifyvm", :id, "--ioapic", "on"]
      end
    
      # Varnish.
      config.vm.define "varnish" do |varnish|
        varnish.vm.hostname = "varnish.dev"
        varnish.vm.network :private_network, ip: "192.168.2.2"
      end
    
      # Apache.
      config.vm.define "www1" do |www1|
        www1.vm.hostname = "www1.dev"
        www1.vm.network :private_network, ip: "192.168.2.3"
    
        www1.vm.provision "shell",
          inline: "sudo yum update -y"
    
        www1.vm.provider :virtualbox do |v|
          v.customize ["modifyvm", :id, "--memory", 256]
        end
      end
    
      # Apache.
      config.vm.define "www2" do |www2|
        www2.vm.hostname = "www2.dev"
        www2.vm.network :private_network, ip: "192.168.2.4"
    
        www2.vm.provision "shell",
          inline: "sudo yum update -y"
    
        www2.vm.provider :virtualbox do |v|
          v.customize ["modifyvm", :id, "--memory", 256]
        end
      end
    
      # MySQL.
      config.vm.define "db1" do |db1|
        db1.vm.hostname = "db1.dev"
        db1.vm.network :private_network, ip: "192.168.2.5"
      end
    
      # MySQL.
      config.vm.define "db2" do |db2|
        db2.vm.hostname = "db2.dev"
        db2.vm.network :private_network, ip: "192.168.2.6"
      end
    
      # Memcached.
      config.vm.define "memcached" do |memcached|
        memcached.vm.hostname = "memcached.dev"
        memcached.vm.network :private_network, ip: "192.168.2.7"
    
        # Run Ansible provisioner once for all VMs at the end.
        memcached.vm.provision "ansible" do |ansible|
          ansible.playbook = "configure.yml"
          ansible.inventory_path = "inventories/vagrant/inventory"
          ansible.limit = "all"
          ansible.extra_vars = {
            ansible_ssh_user: 'vagrant',
            ansible_ssh_private_key_file: "~/.vagrant.d/insecure_private_key"
          }
        end
      end
    end

For the last block of code, which defines the `ansible` provisioner configuration, most options are typical of any provisioner's configuration, but there are three values that are important for our purposes:

{lang=ruby}
          ansible.inventory_path = "inventories/vagrant/inventory"
          ansible.limit = "all"
          ansible.extra_vars = {
            ansible_ssh_user: 'vagrant',
            ansible_ssh_private_key_file: "~/.vagrant.d/insecure_private_key"
          }

  1. `ansible.inventory_path` defines an inventory file to be used with the `ansible.playbook`. You could certainly create a dynamic inventory script for use with Vagrant, but because we know the IP addresses ahead of time, and are expecting a few specially-crafted inventory group names, it's simpler to build the inventory file for Vagrant provisioning by hand.
  2. `ansible.limit` is set to `all` so Vagrant knows it should run the Ansible playbook connected to all VMs, and not just the current VM. You could technically use `ansible.limit` with a provisioner configuration for each of the individual VMs, and just run the VM-specific playbook through Vagrant, but since our live production infrastructure will be using one playbook to configure all the servers, it's best to replicate that scenario locally.
  3. `ansible.extra_vars` contains the vagrant SSH user configuration for Ansible. You normally would not need to define these values if you either include them in static inventory files, or use Vagrant's automatically-generated inventory file (if `ansible.inventory_path` is not defined).

Now, before running `vagrant up` to see the fruits of our labor so far, we need to create the inventory file at `inventories/vagrant/inventory`:

{lang=text}
    [lamp-varnish]
    192.168.2.2
    
    [lamp-www]
    192.168.2.3
    192.168.2.4
    
    [a4d.lamp.db.1]
    192.168.2.5
    
    [lamp-db]
    192.168.2.5
    192.168.2.6
    
    [lamp-memcached]
    192.168.2.7

Now, with this inventory file created, you should be able to `cd` into the project's root directory, run `vagrant up`, and after ten or fifteen minutes, load `http://192.168.2.2/` in your browser, which should return something like the following:

{width=80%}
![Highly Available Infrastructure - Success!](images/8-ha-infrastructure-success.png)

This is great for local development purposes, but how hard is it to get the exact same infrastructure configuration running on a cloud provider? As it turns out, Ansible makes it fairly straightforward.

### Provisioner Configuration: DigitalOcean

As we learned in Chapter 7, it's simple enough to provision a new DigitalOcean droplet and begin configuring it immediately. But we need to take provisioning a step further, provisioning multiple droplets (one for each server in our infrastructure) and dynamically grouping them so we can configure them after they are booted and online.

For the sake of flexibility (we want to be able to use a variety of cloud-based services, in addition to the already defined Vagrant provisioning configuration), let's create a playbook for our DigitalOcean droplets in `provisioners/digitalocean.yml`. As with our example in Chapter 7, we will use a local connection to provision cloud instances, so begin the playbook with:

{lang=text}
    ---
    - hosts: localhost
      connection: local
      gather_facts: false

Next, since we want to provision multiple droplets, but we don't want to repeat the same task over and over for each droplet, let's define the minimum required droplet configuration necessary for provisioning:

{lang=text,starting-line-number=6}
      vars:
        droplets:
          - { name: a4d.lamp.varnish, group: "lamp-varnish" }
          - { name: a4d.lamp.www.1, group: "lamp-www" }
          - { name: a4d.lamp.www.2, group: "lamp-www" }
          - { name: a4d.lamp.db.1, group: "lamp-db" }
          - { name: a4d.lamp.db.2, group: "lamp-db" }
          - { name: a4d.lamp.memcached, group: "lamp-memcached" }

Each droplet is an object with two keys:

  - `name`: The name of the Droplet in DigitalOcean's listings and when inventory information is generated.
  - `group`: The Ansible inventory group in which the droplet should belong.

Now that we have some generic metadata for each droplet, let's add a task to create the droplets, then register their information in a separate dictionary:

{lang=text,starting-line-number=15}
      tasks:
        - name: Provision DigitalOcean droplets.
          digital_ocean:
            state: "{{ item.state | default('present') }}"
            command: droplet
            name: "{{ item.name }}"
            private_networking: yes
            size_id: "{{ item.size | default(66) }}" # 512mb
            image_id: "{{ item.image | default(6372108) }}" # CentOS 6 x64.
            region_id: "{{ item.region | default(4) }}" # NYC2
            ssh_key_ids: "{{ item.ssh_key | default('138954') }}" # geerlingguy
            unique_name: yes
          register: created_droplets
          with_items: droplets

Many of the options (e.g. `size_id`) are defined as `{{ item.property | default('default_value') }}`, which allows us to use optional variables per droplet. For any of the defined droplets, we could add `size_id: 72` (or whatever valid value you'd like), and it would override the default value set in the task. Using defaults affords additional flexibility when provisioning infrastructure.

T> You could specify an SSH public key per droplet, or (as in this instance) use the same key for all hosts by providing a default. In this case, I added an SSH key to my DigitalOcean account, then used the DigitalOcean API to retrieve the key's numeric ID (as described in the previous chapter).
T> 
T> It's best to use key-based authentication and add at least one SSH key to your DigitalOcean account so Ansible can connect using keys instead of insecure passwords, especially since these instances will be created with only a root account.

We loop through all the defined `droplets` using `with_items: droplets`, and after each droplet is created, Ansible will add the DigitalOcean metadata (including name, IP address, network information, etc.) about the droplet to the `created_droplets` variable. We can then use that variable to add all the created hosts to our Ansible inventory, so we can then run the configuration playbooks on the right servers:

{lang=text,starting-line-number=30}
        - name: Add DigitalOcean hosts to their respective inventory groups.
          add_host:
            name: "{{ item.1.droplet.ip_address }}"
            groups: "do,{{ droplets[item.0].group }},{{ item.1.droplet.name }}"
            # You can dynamically add inventory variables per-host.
            ansible_ssh_user: root
            mysql_replication_role: >
              "{{ 'master' if (item.1.droplet.name == 'a4d.lamp.db.1')
              else 'slave' }}"
            mysql_server_id: "{{ item.0 }}"
          when: item.1.droplet is defined
          with_indexed_items: created_droplets.results

You'll notice a few interesting things happening in this task:

  - This is the first time we've used `with_indexed_items`. In this case, the primary reason for using this less-common loop feature is so we can add a sequential and unique `mysql_server_id`. Though only the MySQL servers need a server ID set, it's simplest to dynamically create the variable for every server, so it's available when needed. `with_indexed_items` simply sets `item.0` to the key of the item, and `item.1` to the value of the item.
  - The other reason for using `with_indexed_items` is so we can reliably set each droplet's group when adding the host with `add_host`. Because the currently-supported version of DigitalOcean's API doesn't support features like tagging Droplets, we need to set up the groups through our own devices. In this case, using the `droplets` variable we manually created earlier allows us to set the proper group for a particular droplet.
  - Finally, as noted in the comment, you can add inventory variables per-host in add_host, simply by adding the variable name as a key, and the variable value as the key's value. Simple, but powerful!

T> There are a few different ways you can approach dynamic provisioning and inventory management for your infrastructure, and, especially if you are only targeting one cloud hosting provider, there are ways to avoid using more exotic features of Ansible (e.g. `with_indexed_items`) and complex if/else conditions. This example is slightly more complex due to the fact that the playbook is being created to be interchangeable with other similar provisioning playbooks.

The final step in our provisioning is to make sure all the droplets are booted and can be reached via SSH, so at the end of the `digitalocean.yml` playbook, add another play to be run on all the `digitalocean` hosts (which we just defined in the `add_host` task):

{lang=text,starting-line-number=43}
    - hosts: do
      remote_user: root

      tasks:
        - name: Wait for port 22 to become available.
          local_action: "wait_for port=22 host={{ inventory_hostname }}"

We simply need to wait for port 22 to be reachable, and once that's verified, we will be able to configure the droplets.

We're *almost* ready to provision and configure our entire infrastructure on DigitalOcean, we just need one final playbook (let's call it `provision.yml`, and place it in the root directory of our project) to put everything together:

{lang=text}
    ---
    - include: provisioners/digitalocean.yml
    - include: configure.yml

That's it! Now, assuming the environment variables `DO_CLIENT_ID` and `DO_API_KEY` are set in your current terminal session, you can run `$ ansible-playbook provision.yml`.

The entire process should take about 15 minutes, and once it's complete, you should see something like:

{lang=text,linenos=off}
    PLAY RECAP *****************************************************************
    107.170.27.137             : ok=19   changed=13   unreachable=0    failed=0
    107.170.3.23               : ok=13   changed=8    unreachable=0    failed=0
    107.170.51.216             : ok=40   changed=18   unreachable=0    failed=0
    107.170.54.218             : ok=27   changed=16   unreachable=0    failed=0
    162.243.20.29              : ok=24   changed=15   unreachable=0    failed=0
    192.241.181.197            : ok=40   changed=18   unreachable=0    failed=0
    localhost                  : ok=2    changed=1    unreachable=0    failed=0

Visit the IP address of the varnish server and you should be greeted with a status page similar to the one generated by the Vagrant-based infrastructure:

{width=80%}
![Highly Available Infrastructure on DigitalOcean.](images/8-ha-infrastructure-digitalocean.png)

If you run the same `ansible-playbook provision.yml` command again, since everything in this playbook is idempotent, Ansible will run through the entire process of provisioning and configuring your infrastructure, and report that nothing has changed.

Ansible will also rebuild and reconfigure any droplets that may be missing from your infrastructure. If you're daring, and want to test this feature, just log into your DigitalOcean account, delete one of the droplets just created by this playbook, then run the playbook again.

Now that we've tested our infrastructure on DigitalOcean, we can destroy the droplets just as easily (change the `state` parameter in `provisioners/digitalocean.yml` to default to `'absent'` and run `$ ansible-playbook provision.yml` again), then move on to creating the exact same infrastructure a third time---this time in Amazon's cloud.

### Provisioner Configuration: Amazon Web Services (EC2)

For Amazon Web Services, the provisioning is slightly different. Whereas DigitalOcean's provisioning focuses solely on particular droplets, AWS's provisioning takes into account Amazon's broader ecosystem of services that support EC2 instances. For our purposes, we need only configure security groups (which configure AWS-level firewalls running outside an EC2 instance OS) prior to provisioning our EC2 instances.

For starters, add the file `provisioners/aws.yml` and put the standard play details at the top:

{lang=text}
    ---
    - hosts: localhost
      connection: local
      gather_facts: false

Because we need to configure security groups for our EC2 instances, our defined variables are a little more verbose, and include a list of `security_groups` in addition to the EC2 `instances`. First, the `instances`:

{lang=text,starting-line-number=6}
      vars:
        instances:
          - {
            name: a4d.lamp.varnish,
            group: "lamp-varnish",
            security_group: ["default", "a4d_lamp_http"]
          }
          - {
            name: a4d.lamp.www.1,
            group: "lamp-www",
            security_group: ["default", "a4d_lamp_http"]
          }
          - {
            name: a4d.lamp.www.2,
            group: "lamp-www",
            security_group: ["default", "a4d_lamp_http"]
          }
          - {
            name: a4d.lamp.db.1,
            group: "lamp-db",
            security_group: ["default", "a4d_lamp_db"]
          }
          - {
            name: a4d.lamp.db.2,
            group: "lamp-db",
            security_group: ["default", "a4d_lamp_db"]
          }
          - {
            name: a4d.lamp.memcached,
            group: "lamp-memcached",
            security_group: ["default", "a4d_lamp_memcached"]
          }

Each instance is an object with three keys:

  - `name`: The name of the instance, which will be used by Ansible to tag the instance and ensure only one of this particular instance is created.
  - `group`: The Ansible inventory group in which the instance should belong.
  - `security_group`: A list of security groups into which the instance will be placed. The `default` security group is added to your AWS account when it is created, and typically has one rule to allow all outgoing traffic from a particular instance.

I> Note that it may be a better idea, if using AWS exclusively, to use use a different structure of VMs with autoscaling groups, etc., but for this example, we need to ensure that the six instances we explicitly define are created, so we're using particular `name`s and an `exact_count` to enforce the 1:1 relationship.

We've added security groups to instances, so next we'll define a `security_groups` variable so we can loop through it in a task and ensure all the security groups we need are present:

{lang=text,starting-line-number=39}
        security_groups:
          - name: a4d_lamp_http
            rules:
              - { proto: tcp, from_port: 80, to_port: 80, cidr_ip: 0.0.0.0/0 }
              - { proto: tcp, from_port: 22, to_port: 22, cidr_ip: 0.0.0.0/0 }
            rules_egress: []
          - name: a4d_lamp_db
            rules:
              - { proto: tcp, from_port: 3306, to_port: 3306, cidr_ip: 0.0.0.0/0 }
              - { proto: tcp, from_port: 22, to_port: 22, cidr_ip: 0.0.0.0/0 }
            rules_egress: []
          - name: a4d_lamp_memcached
            rules:
              - { proto: tcp, from_port: 11211, to_port: 11211, cidr_ip: 0.0.0.0/0 }
              - { proto: tcp, from_port: 22, to_port: 22, cidr_ip: 0.0.0.0/0 }
            rules_egress: []

Each security group has a `name` (which matches the name for a given instance in our `instances` list), `rules` (a list of firewall rules like protocol, ports, and IP ranges to limit *incoming* traffic), and `rules_egress` (a list of firewall rules to limit *outgoing* traffic).

We need three security groups: `http` to open port 80, `db` to open port 3306, and `memcached` to open port 11211.

Now that we have all the data we need to set up security groups and instances, the first task needs to to create or verify the existence of the security groups:

{lang=text,starting-line-number=56}
      tasks:
        - name: Configure EC2 Security Groups.
          ec2_group:
            name: "{{ item.name }}"
            description: Example EC2 security group for A4D.
            region: "{{ item.region | default('us-west-2') }}" # Oregon
            state: present
            rules: "{{ item.rules }}"
            rules_egress: "{{ item.rules_egress }}"
          with_items: security_groups

The `ec2_group` module is simple enough to use; give it a name, region, and rules, and your security groups will be created if they don't exist, modified to match the supplied values if they do exist, or simply verified if they exist and match the given values.

Now that we have our security groups configured, we can provision the defined EC2 instances by looping through `instances` with the `ec2` module:

{lang=text,starting-line-number=67}
        - name: Provision EC2 instances.
          ec2:
            key_name: "{{ item.ssh_key | default('jeff_mba_home') }}"
            instance_tags:
              inventory_group: "{{ item.group | default('') }}"
              inventory_host: "{{ item.name | default('') }}"
            group: "{{ item.security_group | default('') }}"
            instance_type: "{{ item.type | default('t2.micro')}}" # Free Tier
            image: "{{ item.image | default('ami-11125e21') }}" # RHEL6 x64 hvm
            region: "{{ item.region | default('us-west-2') }}" # Oregon
            wait: yes
            wait_timeout: 500
            exact_count: 1
            count_tag:
              inventory_group: "{{ item.group | default('') }}"
              inventory_host: "{{ item.name | default('') }}"
          register: created_instances
          with_items: instances

This book is not a thorough guide on all things AWS, but I will explain a few of the details of this module, as it's slightly increased complexity (over our DigitalOcean example) warrants a deeper look:

  - EC2 allows keys to be defined by name---in my case, I have a key `jeff_mba_home` in my AWS account. You should set the `key_name` default to a key that you have in your account.
  - Instance tags are tags that AWS will attach to your instance, for categorization purposes. By giving a list of keys and values, I can then use that list later in the `count_tag` parameter (more on this in a bit).
  - `t2.micro` was used as the default instance type, since it falls within EC2's free tier usage. If you just set up an account and keep all AWS resource usage within free tier limits, you won't be billed anything.
  - `exact_count` and `count_tag` work together to ensure AWS provisions only one of each of the servers we defined. The `count_tag` tells the `ec2` module to match the given group + host and then `exact_count` tells the module to only provision `1` instance. If you wanted to *remove* all your servers, you could set `exact_count` to 0 and run the playbook again.

Each provisioned instance will have its metadata added to the registered `created_instances` variable, and we can use that variable to build up Ansible inventory groups for use in the rest of the infrastructure plays.

{lang=text,starting-line-number=86}
        - name: Add EC2 instances to their respective inventory groups.
          add_host:
            name: "{{ item.1.tagged_instances.0.public_ip }}"
            groups: "aws,{{ item.1.item.group }},{{ item.1.item.name }}"
            # You can dynamically add inventory variables per-host.
            ansible_ssh_user: ec2-user
            mysql_replication_role: >
              {{ 'master' if (item.1.item.name == 'a4d.lamp.db.1')
              else 'slave' }}
            mysql_server_id: "{{ item.0 }}"
          when: item.1.instances is defined
          with_indexed_items: created_instances.results

This `add_host` example is slightly simpler than the one for DigitalOcean, mostly because AWS attaches metadata to EC2 instances that we can re-use when building groups or hostnames (e.g. `item.1.item.group`). This way we don't have to use list indexes to fetch group names from the original `instances` variable.

We again use `with_indexed_items` so we can use the index to generate a unique ID per server for use in building the MySQL master-slave replication.

The final step in provisioning the EC2 instances is to ensure we can connect to them before continuing, and to set `selinux` into permissive mode so the configuration we supply will work correctly.

{lang=text,starting-line-number=86}
    # Run some general configuration on all AWS hosts.
    - hosts: aws
      gather_facts: false
    
      tasks:
        - name: Wait for port 22 to become available.
          local_action: "wait_for port=22 host={{ inventory_hostname }}"
    
        - name: Set selinux into 'permissive' mode.
          selinux: policy=targeted state=permissive
          sudo: yes

Note that, since we defined `ansible_ssh_user` as `ec2-user` in the dynamically-generated inventory above, we need to ensure the `selinux` task runs as `sudo` explicitly.

Now, modify the `provision.yml` file in the root of the project folder, changing the provisioners line to look like the following:

{lang=text}
    ---
    - include: provisioners/aws.yml
    - include: configure.yml

Assuming the environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` are set in your current terminal session, you can run `$ ansible-playbook provision.yml` to provision and configure the infrastructure on AWS.

The entire process should take about 15 minutes, and once it's complete, you should see something like:

{lang=text,linenos=off}
    PLAY RECAP *****************************************************************
    54.148.100.44              : ok=24   changed=16   unreachable=0    failed=0
    54.148.120.23              : ok=40   changed=19   unreachable=0    failed=0
    54.148.41.134              : ok=40   changed=19   unreachable=0    failed=0
    54.148.56.137              : ok=13   changed=9    unreachable=0    failed=0
    54.69.160.32               : ok=27   changed=17   unreachable=0    failed=0
    54.69.86.187               : ok=19   changed=14   unreachable=0    failed=0
    localhost                  : ok=3    changed=1    unreachable=0    failed=0

Visit the IP address of the varnish server and you should be greeted with a status page similar to the one generated by the Vagrant and DigitalOcean-based infrastructure:

{width=80%}
![Highly Available Infrastructure on AWS EC2.](images/8-ha-infrastructure-aws.png)

As with DigitalOcean, running `ansible-playbook provision.yml` again should produce no changes, because everything in this playbook is idempotent. And if one of your instances were terminated, running the playbook again would recreate and reconfigure the instance in a few minutes.

To terminate all the provisioned instances, you can change the `exact_count` in the `ec2` task to `0`, and run `$ ansible-playbook provision.yml` again.

### Summary

In the above example, an entire highly-available PHP application infrastructure was defined in a series of short Ansible playbooks, and then provisioning configuration was created to build the infrastructure on either local VMs, DigitalOcean droplets, or AWS EC2 instances.

Once you start working on building infrastructure this way---first, abstracting individual servers, then abstracting cloud provisioning---you'll start to see some of Ansible's true power in being more than just a configuration management tool. Imagine being able to create your own multi-datacenter, multi-provider infrastructure with Ansible and some basic configuration.

While Amazon, DigitalOcean, Rackspace and other hosting providers have their own tooling and unique infrastructure merits, the agility and flexibility afforded by building infrastructure in a provider-agnostic fashion lets you treat hosting providers as commodities, and gives you freedom to build more reliable, performant, and simple application infrastructure.

Even if you plan on running everything within one hosting provider's network (or in a private cloud, or even on a few bare metal servers), Ansible provides deep stack-specific integration so you can do whatever you need to do and manage the provider's services within your playbooks.

I> You can find the entire contents of this example in the [Ansible for DevOps GitHub repository](https://github.com/geerlingguy/ansible-for-devops), in the `lamp-infrastructure` directory.

## ELK Logging with Ansible

Though application servers and backup servers may be some of the most mission-critical components of a well-rounded infrastructure, one area that is equally important is a decent logging configuration.

In the old days, when one or two servers could handle an entire website or application, you could work with built-in logfiles and rsyslog to troubleshoot an issue or check trends in performance, errors, or overall traffic. With a typical modern infrastructure---like the example above, with six separate servers---it pays dividends to find a better solution for application, server, and firewall/authentication logging. Plain text files, logrotate, and grep don't cut it anymore.

Among various modern logging and reporting toolsets, the 'ELK' stack (Elasticsearch, Logstash, and Kibana) has come to the fore as one of the best-performing and easiest-to-configure open source centralized logging solutions.

{width=80%}
![An example Kibana logging dashboard.](images/8-elk-kibana-example.png)

In our example, we'll configure a single ELK server to handle aggregation, searching, and graphical display of logged data from a variety of other servers, and give some common configuration examples to send common system logs, webserver logs, etc.

### ELK Playbook

Just like our previous example, we're going to let a few roles from Ansible Galaxy do the heavy lifting of actually installing and configuring Elasticsearch, Logstash, and Kibana. If you're interested in reading through the roles that do this work, feel free to peruse them after you've downloaded them.

In this example, rather than walking through each role and variable in detail, I'm going to highlight the important parts, but then jump immediately into how you can use this base server to aggregate logs, then how to point your other servers' log files to it using Logstash Forwarder.

Here's our main playbook, saved as `provisioning/playbook.yml`:

{lang=text}
    - hosts: logs
      gather_facts: yes
    
      vars_files:
        - vars/main.yml
    
      pre_tasks:
        - name: Update apt cache if needed.
          apt: update_cache=yes cache_valid_time=86400
    
      roles:
        - geerlingguy.java
        - geerlingguy.nginx
        - geerlingguy.elasticsearch
        - geerlingguy.elasticsearch-curator
        - geerlingguy.kibana
        - geerlingguy.logstash
        - geerlingguy.logstash-forwarder

This assumes you have a `logs` group in your inventory with at least one server listed. The playbook includes a vars file located in `provisioning/vars/main.yml`, so create that file, and then put the following inside:

{lang=text}
    ---
    java_packages:
      - openjdk-7-jdk
    
    nginx_user: www-data
    nginx_worker_connections: 1024
    nginx_remove_default_vhost: true
    
    kibana_server_name: logs
    kibana_username: kibana
    kibana_password: password
    
    logstash_monitor_local_syslog: false
    logstash_forwarder_files:
      - paths:
          - /var/log/auth.log
        fields:
          type: syslog

Obviously, you'll want to use a different password besides 'password' for `kibana_password`, so set something more secure there. Other options are relatively standard, with the exception of the two `logstash_*` variables.

The first variable tells the `geerlingguy.logstash` role to ignore the local syslog file (in this case, we're only interested in logging authorization attempts through the local `auth.log`).

The second variable gives the `geerlingguy.logstash-forwarder` role a list of files to monitor, along with metadata to tell logstash what kind of file is being monitored. In this case, we are only worried about the `auth.log` file, and we know it's a syslog-style file. (Logstash needs to know what kind of file you're monitoring so it can parse the logged messages correctly).

If you want to get this ELK server up and running quickly, you can create a local VM using Vagrant like you have in most other examples in the book. Create a `Vagrantfile` in the same directory as the `provisioning` folder, with the following contents:

{lang=ruby}
    # -*- mode: ruby -*-
    # vi: set ft=ruby :
    
    VAGRANTFILE_API_VERSION = "2"
    
    Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
      config.vm.box = "geerlingguy/ubuntu1204"
    
      config.vm.provider :virtualbox do |v|
        v.customize ["modifyvm", :id, "--name", "logs"]
        v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        v.customize ["modifyvm", :id, "--memory", 1024]
        v.customize ["modifyvm", :id, "--cpus", 2]
        v.customize ["modifyvm", :id, "--ioapic", "on"]
      end
    
      config.vm.hostname = "logs"
      config.vm.network :private_network, ip: "192.168.9.90"
    
      # Set the name of the VM. See: http://stackoverflow.com/a/17864388/100134
      config.vm.define :logs do |logs_config|
      end
    
      # Ansible provisioner.
      config.vm.provision :ansible do |ansible|
        ansible.playbook = "provisioning/playbook.yml"
        ansible.inventory_path = "provisioning/inventory"
        ansible.sudo = true
      end
    end

This Vagrant configuration expects an inventory file at `provisioning/inventory`, so quickly create one with the following contents:

{lang=text}
    logs ansible_ssh_host=192.168.9.90 ansible_ssh_port=22

Now, run `vagrant up`. The build should take about five minutes, and upon completion, if you add a line like `logs  192.168.9.90` to your `/etc/hosts` file, you can visit `http://logs/` in your browser and see Kibana's default homepage:

{width=80%}
![Kibana's default homepage.](images/8-elk-kibana-default.png)

Kibana helpfully links to an example dashboard for Logstash (under the "Are you a Logstash User?" section), and if you select it, you should see a live dashboard that shows logged activity for the past day:

{width=80%}
![Kibana's default Logstash dashboard.](images/8-elk-kibana-logstash-dashboard.png)

This example won't dive too deep into customizing Kibana's dashboard customization, since there are many guides to using Kibana available freely, including [Kibana's official guide](http://www.elasticsearch.org/guide/en/kibana/current/index.html). For our purposes, we'll simply use the default dashboard.

I> This example uses Kibana 3.x, but a stable release of Kibana 4.x is on the horizon (as of early 2015). Some of the screenshots may show a different interface than the latest release, but this book will likely be updated with newer screenshots and updated guides once the 4.x release comes out.

### Forwarding Logs from Other Servers

It's great that we have the ELK stack running; Elasticsearch is quietly storing and querying log data in a per-day search index, Logstash is listening for log entries, Logstash Forwarder is running on the server, and sending new entries in `/var/log/auth.log` to Logstash, and Kibana is displaying useful visualizations of the logged data.

But we want to monitor the health and activity of all the servers in our infrastructure. Luckily, configuring additional servers to direct log activity to our new Logstash server is fairly simple using Logstash Forwarder. The basic steps we'll follow are:

  1. Set up a new server in the Vagrantfile.
  2. Set up an Ansible playbook to install and configure Logstash Forwarder.
  3. Boot the server and watch as the logs are forwarded to the main ELK server.

TODO.

### Summary

TODO.

## Mac Provisioning with Ansible and Homebrew

TODO:

  - [Mac Development Ansible Playbook](https://github.com/geerlingguy/mac-dev-playbook)

## Docker-based Infrastructure with Ansible

TODO:

  - [Ansible's Docker module](http://docs.ansible.com/docker_module.html)
  - [Managing CoreOS with Ansible](https://coreos.com/blog/managing-coreos-with-ansible/)
  - [Fun with containers](http://www.slideshare.net/abadger1999/fun-withcontainers)
  - [Testing Ansible Galaxy Roles with Docker](http://copperlight.github.io/ansible/2014/10/14/Testing-Ansible-Galaxy-Roles-with-Docker/)

## Summary

TODO.

{lang=text,linenos=off}
     _________________________________________
    / Any sufficiently advanced technology is \
    | indistinguishable from magic.           |
    \ (Arthur C. Clarke)                      /
     -----------------------------------------
            \   ^__^
             \  (oo)\_______
                (__)\       )\/\
                    ||----w |
                    ||     ||
